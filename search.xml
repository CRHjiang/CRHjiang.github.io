<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>二分法</title>
      <link href="/2023/03/31/%E4%BA%8C%E5%88%86%E6%B3%95/"/>
      <url>/2023/03/31/%E4%BA%8C%E5%88%86%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>二分最重要的是要明白搜索区间的概念，这样才能够确定循环的条件，确定判断之后的执行动作。</p><h3 id="基础二分"><a href="#基础二分" class="headerlink" title="基础二分"></a>基础二分</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> target)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left &gt;&gt; <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line"><span class="keyword">return</span> mid;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">left = mid + <span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">right = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果给定数组中有多个值相同，我们要返回相同数最左侧的值的索引，怎么办？<br>可以在以上基础上改造，也就是 求左侧区间的二分。<br>上面是左闭右闭的区间，下面使用左闭右开的方式。</p><h3 id="左侧区间二分"><a href="#左侧区间二分" class="headerlink" title="左侧区间二分"></a>左侧区间二分</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//寻找左侧边界的二分法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">left_bound</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left &gt;&gt; <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">right = mid;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">left = mid + <span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">right = mid;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同理，也可以求右侧区间。</p><h3 id="右侧区间二分"><a href="#右侧区间二分" class="headerlink" title="右侧区间二分"></a>右侧区间二分</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">right_bound</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left &gt;&gt; <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">left = mid + <span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">left = mid + <span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">right = mid;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> left - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通常我们更习惯使用左闭右开的方式来确定二分的左右区间，这一点要注意。</p><p>上面只是最基础的应用，具体到其它题目会有不同的变式，要根据题目来进行相应的变化。<br>while循环里的if判断条件不一定是三个，具体情况具体分析。</p>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 刷题总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>差分</title>
      <link href="/2023/03/30/%E5%B7%AE%E5%88%86%E6%80%9D%E6%83%B3/"/>
      <url>/2023/03/30/%E5%B7%AE%E5%88%86%E6%80%9D%E6%83%B3/</url>
      
        <content type="html"><![CDATA[<p>前缀和主要适⽤的场景是原始数组不会被修改的情况下，频繁查询某个区间的累加和。<br>差分数组的主要适⽤场景是频繁对原始数组的某个区间的元素进⾏增减，然后可能还会让你返回经过多次修改后的数组。</p><h3 id="差分的工具类："><a href="#差分的工具类：" class="headerlink" title="差分的工具类："></a>差分的工具类：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Difference</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span>[] diff;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造差分数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Difference</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line"><span class="keyword">assert</span> nums.length &gt; <span class="number">0</span> ;</span><br><span class="line">diff = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">diff[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> ; i &lt; diff.length ; i++) &#123;</span><br><span class="line">diff[i] = nums[i] - nums[i-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//给数组指定区域做加或减操作</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">diff[i] += val;</span><br><span class="line"><span class="keyword">if</span> (j + <span class="number">1</span> &lt; diff.length) &#123;</span><br><span class="line">diff[j + <span class="number">1</span>] -= val;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回操作完成之后的原数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] result() &#123;</span><br><span class="line"><span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[diff.length];</span><br><span class="line">res[<span class="number">0</span>] = diff[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> ; i &lt; res.length ; i++) &#123;</span><br><span class="line">res[i] = res[i-<span class="number">1</span>] + diff[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="leetcode-1109-航班预定统计"><a href="#leetcode-1109-航班预定统计" class="headerlink" title="leetcode 1109 航班预定统计"></a>leetcode 1109 航班预定统计</h3><p>这道题就是典型的差分的思想的应用。<br>重点是要理解题目的意思，只要理解了题目的意思，然后联想到差分数组的特点，就可以很轻松的解决。</p><p>题目中所谓的订票，其实就是对一个数组进行加减操作，这正好契合差分数组的思想。<br>需要注意的就是索引问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] corpFlightBookings(<span class="type">int</span>[][] bookings, <span class="type">int</span> n) &#123;</span><br><span class="line">    <span class="comment">// nums 初始化为全 0</span></span><br><span class="line">    <span class="type">int</span>[] nums = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    <span class="comment">// 构造差分解法</span></span><br><span class="line">    <span class="type">Difference</span> <span class="variable">df</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Difference</span>(nums);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>[] booking : bookings) &#123;</span><br><span class="line">        <span class="comment">// 注意转成数组索引要减⼀哦</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> booking[<span class="number">0</span>] - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> booking[<span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> booking[<span class="number">2</span>];</span><br><span class="line">        <span class="comment">// 对区间 nums[i..j] 增加 val</span></span><br><span class="line">        df.increment(i, j, val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回最终的结果数组</span></span><br><span class="line">    <span class="keyword">return</span> df.result();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 刷题总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前缀和</title>
      <link href="/2023/03/29/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
      <url>/2023/03/29/%E5%89%8D%E7%BC%80%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h1><h3 id="leetcode-303-区域和检索-数组不可变"><a href="#leetcode-303-区域和检索-数组不可变" class="headerlink" title="leetcode 303 区域和检索 - 数组不可变"></a>leetcode 303 区域和检索 - 数组不可变</h3><p>这其实就是前缀和的最基本的应用。</p><p>题目是给我们一个区间，让我们求数组在这个区间上的和，要求我们构造一个类来写。</p><p>我们需要知道的是：preSum[i] 储存的是nums[0…i-1]的和。<br>那么，我们现在要求区间[left，right]区间所有值的和，只需要让preSum[right + 1] - preSum[left]就可以了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumArray</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] preSum;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NumArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">//this.nums = nums;</span></span><br><span class="line">        preSum = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length + <span class="number">1</span>];</span><br><span class="line">        preSum[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> ; i &lt; preSum.length ; i++)&#123;</span><br><span class="line">            preSum[i] = preSum[i - <span class="number">1</span>] + nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumRange</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="comment">//这种方法时间复杂度太高</span></span><br><span class="line">        <span class="comment">// int sum = 0;</span></span><br><span class="line">        <span class="comment">// for (;left &lt;= right;left++)&#123;</span></span><br><span class="line">        <span class="comment">//     sum += nums[left];</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// return sum;</span></span><br><span class="line">        <span class="keyword">return</span> preSum[right + <span class="number">1</span>] - preSum[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your NumArray object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * NumArray obj = new NumArray(nums);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.sumRange(left,right);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>对于前缀和的应用，通常有这样的特点：题目中有个体和数值对应的关系。<br>当我们审题时发现有这样的特点，可以思考是否可以像上面那样利用前缀和数组解决问题。</p><h3 id="蓝桥杯13届省赛真题-最少刷题数"><a href="#蓝桥杯13届省赛真题-最少刷题数" class="headerlink" title="蓝桥杯13届省赛真题 最少刷题数"></a>蓝桥杯13届省赛真题 最少刷题数</h3><p>题目描述<br>小蓝老师教的编程课有 N 名学生，编号依次是 1 . . . N。第 i 号学生这学期刷题的数量是 Ai。<br>对于每一名学生，请你计算他至少还要再刷多少道题，才能使得全班刷题比他多的学生数不超过刷题比他少的学生数。</p><p>输入格式<br>第一行包含一个正整数 N。</p><p>第二行包含 N 个整数：A1, A2, A3, . . . , AN.</p><p>输出格式<br>输出 N 个整数，依次表示第 1 . . . N 号学生分别至少还要再刷多少道题。<br>样例输入<br>5<br>12 10 15 20 6<br>样例输出<br>0 3 0 0 7</p><p>以上是题目。这道题有两种方法，下面的是其中一种。还有一种是数学方法，有规律，分奇数偶数。<br>这道题的个体和数据之间有对应，每一个个体都有一个数据，然后想到统计相同数据的个数，进而又想到是否可以由此构造一个前缀和数组，很巧妙。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> day2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStreamWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 前缀和+二分法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> jyj123</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> class 最少刷题数 &#123;</span><br><span class="line"><span class="comment">//因为数据量较大，所以用下面这种方式读取，否则可能会超时</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">BufferedReader</span> <span class="variable">bf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">PrintWriter</span> <span class="variable">pw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(System.out));</span><br><span class="line"></span><br><span class="line"><span class="comment">//还未构造前缀和时preSum[i]代表的是刷题数为i的人的人数有多少</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>[] preSum = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">100010</span>];</span><br><span class="line"><span class="comment">//nums储存每位同学的刷题数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>[] nums = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">100010</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NumberFormatException, IOException &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取数据，总共有多少个数据</span></span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> Integer.parseInt(bf.readLine());</span><br><span class="line"><span class="comment">//将所有数据读取出来，同时以空格分割，储存到一个String数组中</span></span><br><span class="line">String[] s = bf.readLine().split(<span class="string">&quot; &quot;</span>);</span><br><span class="line"><span class="comment">//System.out.println(Arrays.toString(s));</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; n ; i++) &#123;</span><br><span class="line"><span class="comment">//将每一个刷题数据都存入到nums数组中</span></span><br><span class="line">nums[i] = Integer.parseInt(s[i]);</span><br><span class="line"><span class="comment">//给preSum数组赋值，以nums[i]为下标，这样就可以统计人数</span></span><br><span class="line">preSum[nums[i]]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//System.out.println(preSum[15]);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//构造前缀和数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> ; i &lt; preSum.length ; i++) &#123;</span><br><span class="line"><span class="comment">//preSum[i]代表[0...i]的和</span></span><br><span class="line">preSum[i] = preSum[i] + preSum[i-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//计算每一个学生要刷的题数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; n ; i++) &#123;</span><br><span class="line"><span class="comment">//判断的依据是 刷题数量人数更多的和更少的比较</span></span><br><span class="line"><span class="keyword">if</span> ((n - preSum[nums[i]]) &lt;= preSum[nums[i] - <span class="number">1</span>]) &#123;</span><br><span class="line"><span class="comment">//可以摆烂了，不用刷题了，为0</span></span><br><span class="line">pw.print(<span class="number">0</span> + <span class="string">&quot; &quot;</span>);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//不然的话，要卷起来，刷题，用二分法来找当前学生要刷多少题</span></span><br><span class="line"><span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> nums[i] + <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">100000</span>;</span><br><span class="line"><span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + (r - l &gt;&gt; <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> ((n - preSum[mid]) &lt;= preSum[mid-<span class="number">1</span>] - <span class="number">1</span>) &#123;</span><br><span class="line">r = mid;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">l = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> l - nums[i];</span><br><span class="line">pw.print( a + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">pw.flush();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="leetcode-304-二维区域和检索-数组不可变"><a href="#leetcode-304-二维区域和检索-数组不可变" class="headerlink" title="leetcode 304 二维区域和检索-数组不可变"></a>leetcode 304 二维区域和检索-数组不可变</h3><p>这是前缀和思想在二维数组中的应用。</p><p>这题最关键的是：<br>1、求一个子矩阵的元素和可以分解为：从矩阵四个点开始，分别和原点都可以构成一个新的矩阵。<br>那么，子矩阵和&#x3D;(右下,原点)矩阵和-(左下,原点)矩阵和-(右上,原点)矩阵和+(左上,原点)矩阵和。<br>之所以要加最后的，是因为重复减去了这一部分的面积。</p><p>这题我们同样构造一个类，构造前缀和二维数组，每一个preSum[i][j]都储存着(此刻点,原点)矩阵和，<br>然后我们想求那个子矩阵的和，就根据上面那个公式就可以了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumMatrix</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[][] preSum;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NumMatrix</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> matrix.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> matrix[<span class="number">0</span>].length;</span><br><span class="line">        preSum = <span class="keyword">new</span> <span class="title class_">int</span>[m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> ; i &lt;= m ; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span> ; j &lt;= n ; j++)&#123;</span><br><span class="line">                preSum[i][j] = preSum[i][j-<span class="number">1</span>] + preSum[i-<span class="number">1</span>][j] + matrix[i-<span class="number">1</span>][j-<span class="number">1</span>]</span><br><span class="line">                 -preSum[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumRegion</span><span class="params">(<span class="type">int</span> row1, <span class="type">int</span> col1, <span class="type">int</span> row2, <span class="type">int</span> col2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> preSum[row2 + <span class="number">1</span>][col2 + <span class="number">1</span>] - preSum[row1][col2 + <span class="number">1</span>] - preSum[row2+<span class="number">1</span>][col1]+ preSum[row1][col1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 刷题总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>洛谷刷题笔记</title>
      <link href="/2023/03/12/%E6%B4%9B%E8%B0%B7%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
      <url>/2023/03/12/%E6%B4%9B%E8%B0%B7%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h3 id="洛谷-P1001-A-B-Problem"><a href="#洛谷-P1001-A-B-Problem" class="headerlink" title="洛谷 P1001 A+B Problem"></a>洛谷 P1001 A+B Problem</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        <span class="comment">//System.out.print(&quot; &quot;);</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        System.out.print(a+b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这里的题目要求输入：10 30这样，中间要有一个空格。</p><p>原本我是想加的，但是报错，注释掉就过了。</p><h3 id="洛谷-B2005-字符三角形"><a href="#洛谷-B2005-字符三角形" class="headerlink" title="洛谷 B2005 字符三角形"></a>洛谷 B2005 字符三角形</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ;i&lt;<span class="number">3</span> ;i++)&#123;</span><br><span class="line">            a = <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">            b = (<span class="number">5</span> - a) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> b ;j &gt; <span class="number">0</span> ;j--)&#123;</span><br><span class="line">                System.out.print(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> a ;k &gt; <span class="number">0</span> ;k--)&#123;</span><br><span class="line">                System.out.print(str);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="洛谷-P5703-【深基2-例5】苹果采购"><a href="#洛谷-P5703-【深基2-例5】苹果采购" class="headerlink" title="洛谷 P5703 【深基2.例5】苹果采购"></a>洛谷 P5703 【深基2.例5】苹果采购</h3><p>题目有点问题。</p><p>说的是要输入正整数，那就不能包括0，那么进行判断的时候应该大于0才能继续，但是案例通不过，大于等于0通过了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        <span class="keyword">if</span> (a &gt;= <span class="number">0</span> &amp;&amp; b &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.print(a * b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="洛谷-P5704-【深基2-例6】字母转换"><a href="#洛谷-P5704-【深基2-例6】字母转换" class="headerlink" title="洛谷 P5704 【深基2.例6】字母转换"></a>洛谷 P5704 【深基2.例6】字母转换</h3><p>知识点：</p><p>1、一个小写英文字母，ASCII码-32就是对应的大写字母。</p><p>2、charAt方法，可以将一个字符转为char类型，括号里面的数字是下标，比如输入abcde，对应的下标就是01234，想要将哪个转化，就填哪个下标。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        </span><br><span class="line">        <span class="type">char</span> <span class="variable">a</span> <span class="operator">=</span> sc.next().charAt(<span class="number">0</span>);</span><br><span class="line">        System.out.print((<span class="type">char</span>)(a-<span class="number">32</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="洛谷-P5705-【深基2-例7】数字反转"><a href="#洛谷-P5705-【深基2-例7】数字反转" class="headerlink" title="洛谷 P5705 【深基2.例7】数字反转"></a>洛谷 P5705 【深基2.例7】数字反转</h3><p>思路：用栈来实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in); </span><br><span class="line">        Stack&lt;Character&gt; st = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;(); </span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> sc.next();</span><br><span class="line"><span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;str.length(); i++) &#123;</span><br><span class="line"><span class="type">char</span> <span class="variable">a</span> <span class="operator">=</span> str.charAt(i);</span><br><span class="line">st.push(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;str.length(); i++) &#123;</span><br><span class="line">b = b + st.pop();</span><br><span class="line">&#125;</span><br><span class="line">System.out.print(Float.parseFloat(b));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="洛谷-P5707-【深基2-例12】上学迟到"><a href="#洛谷-P5707-【深基2-例12】上学迟到" class="headerlink" title="洛谷 P5707 【深基2.例12】上学迟到"></a>洛谷 P5707 【深基2.例12】上学迟到</h3><p>知识点：</p><p>1、Calendar date &#x3D; Calendar.getInstance();</p><p>注意这个实例的add和set</p><p>2、SimpleDateFormat的format方法参数必须是一个长类型的，而所有时间类型都可以转为长类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="type">Calendar</span> <span class="variable">date</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">        date.set(<span class="number">2021</span>, Calendar.MAY, <span class="number">5</span>, <span class="number">8</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        date.add(Calendar.MINUTE, -<span class="number">10</span>);</span><br><span class="line">        date.add(Calendar.MINUTE, s % y == <span class="number">0</span> ? -(s / y) : -(s / y) - <span class="number">1</span>);</span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">format</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;HH:mm&quot;</span>);</span><br><span class="line">        System.out.println(format.format(date.getTime()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="洛谷-P5711-【深基3-例3】闰年判断"><a href="#洛谷-P5711-【深基3-例3】闰年判断" class="headerlink" title="洛谷 P5711 【深基3.例3】闰年判断"></a>洛谷 P5711 【深基3.例3】闰年判断</h3><p>这道题就是需要知道什么是闰年。</p><p>能被400整除或者能被4整除同时不能被100整除，符合这样的标准的就是闰年。</p><p>这题没什么难度，但如果不知道什么是闰年，那就写不出来了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">year</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        <span class="keyword">if</span> ( </span><br><span class="line">            (year % <span class="number">400</span>) == <span class="number">0</span> ||</span><br><span class="line">            ((year % <span class="number">4</span> == <span class="number">0</span>) &amp;&amp; (year % <span class="number">100</span> != <span class="number">0</span>))</span><br><span class="line">        )&#123;</span><br><span class="line">            System.out.println(<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="洛谷-P5718-【深基4-例2】找最小值"><a href="#洛谷-P5718-【深基4-例2】找最小值" class="headerlink" title="洛谷 P5718 【深基4.例2】找最小值"></a>洛谷 P5718 【深基4.例2】找最小值</h3><p>这题没什么难度，方法也有很多。</p><p>下面只是一种。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; a ; i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">            min = b &lt; min ? b : min;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(min);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="洛谷-P1009-NOIP1998-普及组-阶乘之和"><a href="#洛谷-P1009-NOIP1998-普及组-阶乘之和" class="headerlink" title="洛谷 P1009 [NOIP1998 普及组] 阶乘之和"></a>洛谷 P1009 [NOIP1998 普及组] 阶乘之和</h3><p>这类题目有一个统称，叫大数问题。顾名思义，就是数值很大。</p><p>这道题有点坑。要注意的是最高可以到50的阶乘，不管是用int还是long都不行，都会溢出。</p><p>这里要考虑高精度的问题。</p><p>在Java里面有处理高精度的方法，下面就是采用这种方法来处理这个问题的，但是蓝桥杯里面解决大数问题最好使用python，</p><p>具有天然优势。当然这里说的是小题，也就是填空题。</p><p>new BigInteger(x + “”)；实例化需要一个字符串类型。</p><p>具体加减乘除都是采用方法来表示。</p><p>multiply(new BigInteger(x + “”)) 方法里面需要一个BigInteger对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.math.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">BigInteger</span> <span class="variable">bi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(sum + <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> ; i &lt;= s ; i++)&#123;</span><br><span class="line">        bi = bi.add(dodata(i));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(bi);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> BigInteger <span class="title function_">dodata</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(x == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(x + <span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(dodata(x-<span class="number">1</span>) + <span class="string">&quot;&quot;</span>).multiply(<span class="keyword">new</span> <span class="title class_">BigInteger</span>(x + <span class="string">&quot;&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="洛谷-P5723-【深基4-例13】质数口袋"><a href="#洛谷-P5723-【深基4-例13】质数口袋" class="headerlink" title="洛谷 P5723 【深基4.例13】质数口袋"></a>洛谷 P5723 【深基4.例13】质数口袋</h3><p>这道题就是需要考虑一下如果采用暴力的方法，时间会不会超出。</p><p>可以先用埃筛选出范围内所有的质数，然后再进行下一步的处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.math.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">boolean</span>[] prime = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">100000</span>];</span><br><span class="line">        prime[<span class="number">0</span>] = prime[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//下面的for循环就是埃筛，但是要注意i循环条件，我有看到写 i &lt;= 100000 的。但是下面也通过了。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span> ; i &lt; <span class="number">100000</span> ; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!prime[i])&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i * <span class="number">2</span>; j &lt; <span class="number">100000</span>; j += i)&#123;</span><br><span class="line">                    prime[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span> ; i &lt; <span class="number">100000</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!prime[i])&#123;</span><br><span class="line">                <span class="keyword">if</span> (i &lt;= l)&#123;</span><br><span class="line">                    System.out.println(i);</span><br><span class="line">                    l -= i;</span><br><span class="line">                    sum++;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="洛谷-P1217-USACO1-5-回文质数-Prime-Palindromes"><a href="#洛谷-P1217-USACO1-5-回文质数-Prime-Palindromes" class="headerlink" title="洛谷 P1217 [USACO1.5]回文质数 Prime Palindromes"></a>洛谷 P1217 [USACO1.5]回文质数 Prime Palindromes</h3><p>注意！！这题巨烦。</p><p>题目本身是不难的，无非就是两个，先判断回文，再判段质数会好一点，但是！但是！数据规模太大了，一亿，稍不注意就超时了。</p><p>在我看来，这道题其实考点应该在于优化运行时间，运行时间和数据规模是这道题最需要考虑的问题。</p><p><strong>下面的代码在洛谷上还是有最后一个AC没有通过，还是超时，需要注意。如果还要优化的化，个人感觉就是在判断质数的时候再优化一下。</strong></p><p>判断回文还有一个双指针的方法，定义两个变量，同时配合charAt方法。</p><p>需要知道的方法：</p><p>StringBuffer的reverse方法，将原字符串翻转，返回的是一个String类型的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.math.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (a % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            a++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> a ; i &lt;= b ; i += <span class="number">2</span>)&#123;</span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (huiwen(i))&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">2</span>; j &lt;= Math.sqrt(i); j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i % j == <span class="number">0</span>) &#123;</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">huiwen</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> String.valueOf(x);</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(str);</span><br><span class="line">        <span class="keyword">if</span> (str.equals(sb.reverse().toString()))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//下面就是双指针的方法</span></span><br><span class="line"><span class="comment">//       for (int i = 2 ; i &lt; b ; i++)&#123;</span></span><br><span class="line"><span class="comment">//            if (!prime[i] &amp;&amp; i &gt;= a)&#123;</span></span><br><span class="line"><span class="comment">//                String str = i + &quot;&quot;;</span></span><br><span class="line"><span class="comment">//                int n = str.length();</span></span><br><span class="line"><span class="comment">//                if (n == 1) &#123;</span></span><br><span class="line"><span class="comment">//                System.out.println(i);</span></span><br><span class="line"><span class="comment">//                &#125;else &#123;</span></span><br><span class="line"><span class="comment">//                int k = n-1;</span></span><br><span class="line"><span class="comment">//                for (int j = 0 ; j &lt; n / 2 ; j++)&#123;</span></span><br><span class="line"><span class="comment">//                    if (str.charAt(j) == str.charAt(k))&#123;</span></span><br><span class="line"><span class="comment">//                        System.out.println(i);</span></span><br><span class="line"><span class="comment">//                    &#125;</span></span><br><span class="line"><span class="comment">//                    k--;</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line"><span class="comment">//                </span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="洛谷-P5726-【深基4-习9】打分"><a href="#洛谷-P5726-【深基4-习9】打分" class="headerlink" title="洛谷 P5726 【深基4.习9】打分"></a>洛谷 P5726 【深基4.习9】打分</h3><p>这道题不难，就是要注意一下输出格式，要两位小数。</p><p>需要知道的方法：</p><p>Arrays.sort(res);将数组排序</p><p>String.format(“%.2f”, sum &#x2F; (n -2)) 这是String自带的，返回的结果是String类型，设置结果保留几位小数。</p><p>Collections.sort(list); 将一个List集合升序</p><p>list.remove(0); reomve方法可以按照下标删除，也可以按照指定数据删除。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.math.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        Scanner sc= <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">double</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//List&lt;Integer&gt; list = new ArrayList();</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; n ; i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">            res[i] = a;</span><br><span class="line">            <span class="comment">//list.add(a);</span></span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(res);</span><br><span class="line">        res[<span class="number">0</span>] = res[n -<span class="number">1</span>] = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; n ; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (res[i] != -<span class="number">1</span>)&#123;</span><br><span class="line">                sum += res[i];</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        System.out.print(String.format(<span class="string">&quot;%.2f&quot;</span>, sum / (n -<span class="number">2</span>)));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Collections.sort(list);</span></span><br><span class="line">        <span class="comment">// list.remove(0);</span></span><br><span class="line">        <span class="comment">// list.remove(list.length - 1);</span></span><br><span class="line">        <span class="comment">// long sum = list.stream().reduce(Integer::sum).orElse(0) / (n-2);</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="洛谷-P1428-小鱼比可爱"><a href="#洛谷-P1428-小鱼比可爱" class="headerlink" title="洛谷 P1428 小鱼比可爱"></a>洛谷 P1428 小鱼比可爱</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line"><span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">keai</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">a[i] = keai;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n-<span class="number">1</span>; i&gt;=<span class="number">0</span> ; i--) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span> ; j &lt; i ; j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(a[j] &lt; a[i]) &#123;</span><br><span class="line">sum++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">a[i] = sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> num : a) &#123;</span><br><span class="line">System.out.print(num + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="洛谷-P1427-小鱼的数字游戏"><a href="#洛谷-P1427-小鱼的数字游戏" class="headerlink" title="洛谷 P1427 小鱼的数字游戏"></a>洛谷 P1427 小鱼的数字游戏</h3><p>这题利用栈就可以了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">Stack&lt;Integer&gt; st = <span class="keyword">new</span> <span class="title class_">Stack</span>();</span><br><span class="line"><span class="keyword">while</span>(flag) &#123;</span><br><span class="line">num = sc.nextInt();</span><br><span class="line"><span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line">flag = <span class="literal">false</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">st.push(num);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(st.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">System.out.print(st.pop() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="洛谷-P5727-【深基5-例3】冰雹猜想"><a href="#洛谷-P5727-【深基5-例3】冰雹猜想" class="headerlink" title="洛谷 P5727 【深基5.例3】冰雹猜想"></a>洛谷 P5727 【深基5.例3】冰雹猜想</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line"><span class="type">Stack</span> <span class="variable">st</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Stack</span>();</span><br><span class="line">st.push(a);</span><br><span class="line"><span class="keyword">while</span>(a != <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(a % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">a = a / <span class="number">2</span>;</span><br><span class="line">st.push(a);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">a = a * <span class="number">3</span> + <span class="number">1</span>;</span><br><span class="line">st.push(a);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(st.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">System.out.print(st.pop() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="洛谷-P1047-NOIP2005-普及组-校门外的树"><a href="#洛谷-P1047-NOIP2005-普及组-校门外的树" class="headerlink" title="洛谷 P1047 [NOIP2005 普及组] 校门外的树"></a>洛谷 P1047 [NOIP2005 普及组] 校门外的树</h3><p>这题最需要注意的问题：</p><p>区域可能会重复，一旦区域重复，那么重复区域的树只需要去除一次！</p><p>关键就是怎么判断此时扫描到的区域的树是否已经去除了。</p><p>我这里是采用一个Map数组，用一个boolean类型来标记此时这棵树有没有去除。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">HashMap&lt;Integer,Boolean&gt; hm = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt;= l ; i++) &#123;</span><br><span class="line">hm.put(i, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; m ; i++) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">from</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line"><span class="type">int</span> <span class="variable">to</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> from ; j &lt;= to ; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!hm.get(j)) &#123;</span><br><span class="line">hm.put(j, <span class="literal">true</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt;= l ; i ++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!hm.get(i)) &#123;</span><br><span class="line">sum += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.print(sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="洛谷-P2550-AHOI2001-彩票摇奖"><a href="#洛谷-P2550-AHOI2001-彩票摇奖" class="headerlink" title="洛谷 P2550 [AHOI2001]彩票摇奖"></a>洛谷 P2550 [AHOI2001]彩票摇奖</h3><p>逻辑很重要。</p><p>方法：</p><p>Arrays.fill(fin, 0);这个经常用来给数组初始化</p><p>Arrays.binarySearch(right, nosure[j]) &gt; -1 这是自带的二分搜索，如果找不到，就返回-1；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">piao</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line"><span class="type">int</span>[] nosure = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">7</span>]; <span class="comment">//每张票上的数字</span></span><br><span class="line"><span class="type">int</span>[] sure = <span class="keyword">new</span> <span class="title class_">int</span>[piao]; <span class="comment">//每一个下标对应的数据代表一张票中奖数字的个数</span></span><br><span class="line"><span class="type">int</span>[] fin = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">7</span>];<span class="comment">//从0-7，分别代表得六等奖-特等奖的得奖的票数，但是要倒序输出</span></span><br><span class="line">Arrays.fill(fin, <span class="number">0</span>);</span><br><span class="line">Arrays.fill(sure, -<span class="number">1</span>);</span><br><span class="line"><span class="type">int</span>[] right = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">7</span>];<span class="comment">//这是中奖的7个数字</span></span><br><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; <span class="number">7</span> ; i++) &#123;</span><br><span class="line">right[i] = sc.nextInt();</span><br><span class="line">&#125;</span><br><span class="line">Arrays.sort(right);<span class="comment">//中奖只需要数字对上就可以，对相应中奖数字的位置没有要求，所以可以排序</span></span><br><span class="line"><span class="comment">//System.out.print(Arrays.toString(right));</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; piao ; i++) &#123;</span><br><span class="line">num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span> ; j &lt; <span class="number">7</span> ; j++) &#123;</span><br><span class="line">nosure[j] = sc.nextInt();</span><br><span class="line"><span class="comment">//System.out.println(Arrays.binarySearch(right, nosure[j]));</span></span><br><span class="line"><span class="keyword">if</span> (Arrays.binarySearch(right, nosure[j]) &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">num++;</span><br><span class="line"><span class="comment">//System.out.println(num);</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">sure[i] = num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//for (int i = 0 ; i &lt; piao ; i++) &#123;</span></span><br><span class="line"><span class="comment">//System.out.println(sure[i]);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; <span class="number">7</span> ; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span> ; j &lt; piao ; j++) &#123;</span><br><span class="line">                <span class="comment">//查找，从1开始，查找对应所有票中奖数字有没有等于对应数字的</span></span><br><span class="line"><span class="keyword">if</span> (sure[j] == i+<span class="number">1</span>) &#123;</span><br><span class="line">fin[i]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">6</span> ; i &gt;= <span class="number">0</span> ; i--) &#123;</span><br><span class="line">System.out.print(fin[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="洛谷-P1614-爱与愁的心痛"><a href="#洛谷-P1614-爱与愁的心痛" class="headerlink" title="洛谷 P1614 爱与愁的心痛"></a>洛谷 P1614 爱与愁的心痛</h3><p>这题最主要的是要注意索引不要越界。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line"><span class="type">int</span>[] hurt = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; n ; i++) &#123;</span><br><span class="line">hurt[i] = sc.nextInt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt;= n - m ; i++) &#123;</span><br><span class="line">sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i ; j &lt; i + m ; j++) &#123;</span><br><span class="line">sum = sum + hurt[j];</span><br><span class="line">&#125;</span><br><span class="line">min = sum &lt; min ? sum : min; </span><br><span class="line">&#125;</span><br><span class="line">System.out.print(min);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="洛谷-P5733-【深基6-例1】自动修正"><a href="#洛谷-P5733-【深基6-例1】自动修正" class="headerlink" title="洛谷 P5733 【深基6.例1】自动修正"></a>洛谷 P5733 【深基6.例1】自动修正</h3><p>简单。</p><p>方法：</p><p>str.toUpperCase()；将字符串转大写。</p><p>相应的还有转小写的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> sc.next();</span><br><span class="line">        </span><br><span class="line">        System.out.print(str.toUpperCase());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="洛谷-P1914-小书童——凯撒密码"><a href="#洛谷-P1914-小书童——凯撒密码" class="headerlink" title="洛谷 P1914 小书童——凯撒密码"></a>洛谷 P1914 小书童——凯撒密码</h3><p>这题还有一个案例没有通过，只有80分。</p><p>我这个方法最重要的就是判断，就是下面的几个if，因为是和长度联系起来的。我下面的可能有什么条件没有考虑。</p><p>暂时先这样。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> sc.next();</span><br><span class="line">String[] finstr = <span class="keyword">new</span> <span class="title class_">String</span>[str.length()];</span><br><span class="line"><span class="type">char</span>[] tostr = <span class="keyword">new</span> <span class="title class_">char</span>[] &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;f&#x27;</span>,<span class="string">&#x27;g&#x27;</span>,<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;i&#x27;</span>,<span class="string">&#x27;j&#x27;</span>,<span class="string">&#x27;k&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;m&#x27;</span>,<span class="string">&#x27;n&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;p&#x27;</span>,<span class="string">&#x27;q&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;s&#x27;</span>,<span class="string">&#x27;t&#x27;</span>,<span class="string">&#x27;u&#x27;</span>,<span class="string">&#x27;v&#x27;</span>,<span class="string">&#x27;w&#x27;</span>,<span class="string">&#x27;x&#x27;</span>,<span class="string">&#x27;y&#x27;</span>,<span class="string">&#x27;z&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; str.length() ; i++) &#123;</span><br><span class="line"><span class="type">char</span> <span class="variable">a</span> <span class="operator">=</span> str.charAt(i);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span> ; j &lt; tostr.length ; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (a == tostr[j] &amp;&amp; a == <span class="string">&#x27;z&#x27;</span>) &#123;</span><br><span class="line">finstr[i] = String.valueOf(tostr[n - <span class="number">1</span>]);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (a == tostr[j] &amp;&amp; j + n &gt; tostr.length - <span class="number">1</span>) &#123;</span><br><span class="line">finstr[i] = String.valueOf(tostr[j + n -tostr.length]);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (a == tostr[j] &amp;&amp; j + n &lt;= tostr.length - <span class="number">1</span>) &#123;</span><br><span class="line">finstr[i] = String.valueOf(tostr[j + n]);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; str.length() ; i++) &#123;</span><br><span class="line">    System.out.print(finstr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="洛谷-P1125-NOIP2008-提高组-笨小猴"><a href="#洛谷-P1125-NOIP2008-提高组-笨小猴" class="headerlink" title="洛谷 P1125 [NOIP2008 提高组] 笨小猴"></a>洛谷 P1125 [NOIP2008 提高组] 笨小猴</h3><p>这道题最重要的就是计算重复出现次数的方法，利用方法相减求得个数，也就是有多少个重复的字母，非常巧妙。</p><p>同时要注意：</p><p>for循环三个条件，都可以不写，就相当于while(true)；</p><p>像下面那样，第三个不写，然后在方法体中改变i的值，一定要注意！i值必须是要改变的！</p><p>如果i值不变，也就是说让i一直等于某个值，for循环就直接死循环，同时注意观察，如果在循环体第一行写一个输出语句输出i的值，会发现i的初始值不是0，就是说int i &#x3D; 0无效了。下面试过是一直输出1。</p><p>方法：</p><p>str.lastIndexOf(a[i])；返回一个子字符串在字符串中最后出现的索引；</p><p>str.indexOf(a[i])；返回一个子字符串在字符串中第一次出现的索引；</p><p>str.toCharArray();将一个字符串转为字节数组；(因为我们可能需要操作字符，比如排序什么的)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.math.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> sc.next();</span><br><span class="line"><span class="type">int</span>[] arr = doCF(str);</span><br><span class="line"><span class="type">int</span> <span class="variable">maxn</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line"><span class="type">int</span> <span class="variable">minn</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line"><span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">Arrays.sort(arr);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; arr.length ; i++) &#123;</span><br><span class="line">maxn = arr[i] &gt; maxn ? arr[i] : maxn;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> maxn - minn;</span><br><span class="line"><span class="keyword">if</span> (num == <span class="number">0</span> || num == <span class="number">1</span>) &#123;</span><br><span class="line">flag = <span class="literal">false</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;No Answer&quot;</span>);</span><br><span class="line">System.out.println(<span class="number">0</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (num == <span class="number">2</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Lucky Word&quot;</span>);</span><br><span class="line">System.out.println(num);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span> ; i &lt;= Math.sqrt(num) ; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (num % i == <span class="number">0</span>) &#123;</span><br><span class="line">flag = <span class="literal">false</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;No Answer&quot;</span>);</span><br><span class="line">System.out.println(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (flag) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Lucky Word&quot;</span>);</span><br><span class="line">System.out.println(num);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回每个字母重复出现的次数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] doCF(String str) &#123;</span><br><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[str.length()];</span><br><span class="line">Arrays.fill(arr, -<span class="number">1</span>);</span><br><span class="line"><span class="type">char</span>[] a = str.toCharArray();</span><br><span class="line">        <span class="comment">//这里必须先排序，否则下面相减无法求出有多少个相同的字母</span></span><br><span class="line">Arrays.sort(a);</span><br><span class="line">str = String.valueOf(a);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; a.length ;) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> (str.lastIndexOf(a[i]) - str.indexOf(a[i])) + <span class="number">1</span>;</span><br><span class="line">arr[i] = num;</span><br><span class="line">i += (str.lastIndexOf(a[i]) - str.indexOf(a[i])) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="洛谷-P1308-NOIP2011-普及组-统计单词数"><a href="#洛谷-P1308-NOIP2011-普及组-统计单词数" class="headerlink" title="洛谷 P1308 [NOIP2011 普及组] 统计单词数"></a>洛谷 P1308 [NOIP2011 普及组] 统计单词数</h3><p>这题有点惨烈，下面的代码只通过了两个用例，20分。</p><p>我的思路是：</p><p>1、先用方法lastIndexOf，看它的返回值是多少，看到底有没有，如果没有，那就直接输出-1；如果返回值不是-1，那就代表是存在子串的，至于有多少个，再分类讨论；</p><p>2、因为题目要求，必须是完全一样的单词，才叫重复单词，而方法indexOf就算有返回索引，那也只能说明有这个子串，但是这个子串可能是一个单词的一部分，这样的情况要排除。</p><p>我的想法是那就检测：</p><p>a：这个子串返回的索引是不是0，代表是起始位置，那就检测子串结束后面有没有空格；</p><p>b：这个子串前或后是不是空格</p><p>经过上面的步骤后，如果上面通过，那就是一个重复的单词，并且下一次检测要跳过这个子串再开始重复检测。</p><p>But！有bug。哭了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> sc.nextLine().toLowerCase();</span><br><span class="line"><span class="type">String</span> <span class="variable">zstr</span> <span class="operator">=</span> sc.nextLine().toLowerCase();</span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (zstr.lastIndexOf(str) == -<span class="number">1</span>) &#123;</span><br><span class="line">System.out.println(-<span class="number">1</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span> ; index &lt; zstr.length() ;) &#123;</span><br><span class="line">index = zstr.indexOf(str,index);</span><br><span class="line"><span class="keyword">if</span> (index == -<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>((index == <span class="number">0</span> || zstr.charAt(index -<span class="number">1</span>) == <span class="string">&#x27; &#x27;</span>) </span><br><span class="line">&amp;&amp; </span><br><span class="line">zstr.charAt(index + str.length()) == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">sum++;</span><br><span class="line">index += str.length();</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">index += str.length();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (sum != <span class="number">0</span>) &#123;</span><br><span class="line">System.out.println(sum + <span class="string">&quot;, &quot;</span> + zstr.indexOf(str));</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">System.out.println(-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="洛谷-P1553-数字反转（升级版）（实数反转）"><a href="#洛谷-P1553-数字反转（升级版）（实数反转）" class="headerlink" title="洛谷 P1553 数字反转（升级版）（实数反转）"></a>洛谷 P1553 数字反转（升级版）（实数反转）</h3><p>还是有点难度，要考虑清楚。</p><p>下面的代码是我从题解里复制的，感觉很好。</p><p>方法：</p><p>str.split(String x);</p><p>split()方法:<strong>分割字符串,参数regex称为分割符,可以使用正则表达式来表示</strong>。</p><p>注意:String类型是不可变的!分隔符会把字符串拆成若干个子字符串,然后生成一个String数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> in.nextLine();</span><br><span class="line">        String s[] = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">2</span>] ;</span><br><span class="line">        <span class="keyword">if</span>(str.indexOf(<span class="string">&#x27;.&#x27;</span>)!=-<span class="number">1</span>) &#123; <span class="comment">// 识别小数</span></span><br><span class="line">        s = str.split(<span class="string">&quot;\\.&quot;</span>);</span><br><span class="line">        turn(s[<span class="number">0</span>]);</span><br><span class="line">        System.out.print(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">        turn(s[<span class="number">1</span>]);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(str.indexOf(<span class="string">&#x27;/&#x27;</span>)!=-<span class="number">1</span>) &#123; <span class="comment">// 识别分数</span></span><br><span class="line">        s = str.split(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        turn(s[<span class="number">0</span>]);</span><br><span class="line">        System.out.print(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        turn(s[<span class="number">1</span>]);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(str.indexOf(<span class="string">&#x27;%&#x27;</span>)!=-<span class="number">1</span>) &#123; <span class="comment">// 识别百分数</span></span><br><span class="line">        s = str.split(<span class="string">&quot;%&quot;</span>);</span><br><span class="line">        turn(s[<span class="number">0</span>]);</span><br><span class="line">        System.out.print(<span class="string">&quot;%&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123; <span class="comment">// 识别整数</span></span><br><span class="line">        turn(str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 字符反倒</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">turn</span><span class="params">(String str)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag1</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// 标志前面多余的0</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag2</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// 标志后面多余的0</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="comment">// 去除前面多余的0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=str.length()-<span class="number">1</span>;i++) &#123; </span><br><span class="line">    <span class="keyword">if</span>(!flag1 &amp;&amp; str.charAt(i)==<span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    flag1 = <span class="literal">true</span>;</span><br><span class="line">    s += str.charAt(i); <span class="comment">// 表示已去除前面0的字符串</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 去除后面多余的0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=s.length()-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!flag2 &amp;&amp; s.charAt(i)==<span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    flag2 = <span class="literal">true</span>;</span><br><span class="line">System.out.printf(<span class="string">&quot;%s&quot;</span>,s.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span>(str == <span class="string">&quot;&quot;</span> || s == <span class="string">&quot;&quot;</span>) &#123;</span><br><span class="line">    System.out.print(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 洛谷刷题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue笔记</title>
      <link href="/2023/02/28/vue%E7%AC%94%E8%AE%B0-day01/"/>
      <url>/2023/02/28/vue%E7%AC%94%E8%AE%B0-day01/</url>
      
        <content type="html"><![CDATA[<h2 id="1、vue模板语法"><a href="#1、vue模板语法" class="headerlink" title="1、vue模板语法"></a>1、vue模板语法</h2><h3 id="插值语法"><a href="#插值语法" class="headerlink" title="插值语法"></a>插值语法</h3><p>功能: 用于解析<strong>标签体</strong>内容</p><p>语法:  ，xxxx 里面会被当做是js表达式解析</p><h3 id="指令语法"><a href="#指令语法" class="headerlink" title="指令语法"></a><strong>指令语法</strong></h3><p>功能: 解析标签属性、解析标签体内容、绑定事件</p><p>举例：v-bind:href &#x3D; ‘xxxx’ ，xxxx 会作为 js 表达式被解析。<strong>v-bind可以不写，只在前面写一个:号。</strong></p><p>说明：Vue 中有有很多的指令，此处只是用 v-bind 举个例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">   &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">   &lt;title&gt;初见vue&lt;/title&gt;</span><br><span class="line">   &lt;!--引入vue--&gt;</span><br><span class="line">   &lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div id=&quot;root&quot;&gt;</span><br><span class="line">     &lt;h1&gt;Hello,&#123;&#123;name&#125;&#125;&lt;/h1&gt;</span><br><span class="line">     &lt;h1&gt;我的年龄是：&#123;&#123;age&#125;&#125;&lt;/h1&gt;</span><br><span class="line">     &lt;h1&gt;&#123;&#123;1 === 1 ? 0 : 4&#125;&#125;&lt;/h1&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">   &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">     Vue.config.productionTip = false</span><br><span class="line"></span><br><span class="line">     new Vue(&#123;</span><br><span class="line">     el:&#x27;#root&#x27;,</span><br><span class="line">     data:&#123;</span><br><span class="line">        name:&#x27;姜宇杰&#x27;,</span><br><span class="line">        age:23</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;)</span><br><span class="line">   &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h2 id="2、数据绑定"><a href="#2、数据绑定" class="headerlink" title="2、数据绑定"></a>2、数据绑定</h2><h3 id="单向数据绑定"><a href="#单向数据绑定" class="headerlink" title="单向数据绑定"></a>单向数据绑定</h3><p>语法：v-bind:href &#x3D;”xxx” 或简写为 :href</p><p>特点：数据只能从 data 流向页面</p><h3 id="双向数据绑定"><a href="#双向数据绑定" class="headerlink" title="双向数据绑定"></a>双向数据绑定</h3><p>语法：v-mode:value&#x3D;”xxx” 或简写为 v-model&#x3D;”xxx” </p><p>特点：数据不仅能从 data 流向页面，还能从页面流向 data</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">   &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">   &lt;title&gt;初见vue&lt;/title&gt;</span><br><span class="line">   &lt;!--引入vue--&gt;</span><br><span class="line">   &lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;root&quot;&gt;</span><br><span class="line">        &lt;h1&gt;我的名字是：&#123;&#123;name&#125;&#125;&lt;/h1&gt;</span><br><span class="line">        学校的地址：&lt;input type=&quot;text&quot; :value=&quot;school.name&quot;&gt;</span><br><span class="line">        学校的电话：&lt;input type=&quot;text&quot; v-model:value=&quot;school.phone&quot;&gt;</span><br><span class="line">        &lt;!--下面是简写--&gt;</span><br><span class="line">        &lt;!--学校的电话：&lt;input type=&quot;text&quot; v-model=&quot;school.phone&quot;&gt;--&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">       new Vue(&#123;</span><br><span class="line">                el:&#x27;#root&#x27;,</span><br><span class="line">                data:&#123;</span><br><span class="line">                    name:&#x27;Jiang&#x27;,</span><br><span class="line">                    school:&#123;</span><br><span class="line">                        name:&#x27;江西农业大学&#x27;,</span><br><span class="line">                        phone:11111</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><strong>注意：不是所有的情况都适合用v-model，它只适用于那些表单类元素上，而无法用于类似 h标签这样没有value值的标签上面。</strong></p><h2 id="3、MVVM模型"><a href="#3、MVVM模型" class="headerlink" title="3、MVVM模型"></a>3、MVVM模型</h2><ul><li>M：模型(Model) ：对应 data 中的数据</li><li>V：视图(View) ：模板</li><li>VM：视图模型(ViewModel) ： Vue 实例对象</li></ul><p><strong>需要知道的是：我们通过语法从一个vue实例对象中取值的时候，不单单是可以取我们代码写的那些属性。凡是vue对象有的属性，包括那些隐藏的，我们都可以取。</strong></p>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java核心技术卷1笔记</title>
      <link href="/2023/02/18/java%E6%8A%80%E6%9C%AF%E5%8D%B71/"/>
      <url>/2023/02/18/java%E6%8A%80%E6%9C%AF%E5%8D%B71/</url>
      
        <content type="html"><![CDATA[<h1 id="第三章-Java的基本程序设计结构"><a href="#第三章-Java的基本程序设计结构" class="headerlink" title="第三章    Java的基本程序设计结构"></a>第三章    Java的基本程序设计结构</h1><p>1.mian方法必须声明为public，也必须是静态的。如果main方法正常退出，那么程序的退出码为0，表示成功运行了程序；</p><p>2.Java中的所有函数都是某个类的方法，所以main方法必须有一个外壳类；</p><p>3.&#x2F;* *&#x2F;注释不能嵌套；</p><p>4.在Java中，整型的范围与与运行Java的机器无关，所有的数值类型所占据的字节数与平台无关；</p><p>5.十六进制数值前缀0x或0X，八进制有一个前缀0；</p><p>6.Java没有任何无符号类型(unsigned)的int、long、short、bite；</p><p>7.float类型的数据有后缀f或F，没有的就默认为double；</p><p>8.NaN不是一个数字；</p><p>9.变量名必须是一个以<strong>字母或下划线或开头</strong>并由<strong>字母或数字构成的序列，空格不能出现，单下划线_不能作为变量名</strong>；</p><p>10.const是Java保留的关键字，但目前并没有使用；</p><p>11.整数除以0会产生异常，浮点数除以0会得到无穷大或NaN结果，0作被除数时正常；</p><p>12.&amp;和|运算符不采用短路求值方式；</p><p>13.String类的substring(a,b)方法可以从一个字符串中提取一个子串，长度为b-a；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String g=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line">String s=g.substring(<span class="number">0</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>输出一个”hel“字符串；</p><p>14.要想检查两个字符串是否 相等，同时不区分大小写，可以使用equalsIgnoreCase方法；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;hello&quot;</span>.equalsIgnoreCase(<span class="string">&quot;Hello&quot;</span>);</span><br></pre></td></tr></table></figure><p><strong>不要用&#x3D;&#x3D;检测字符串是否相等</strong>！</p><p>15.空串“”长度为0，是一个Java对象；</p><p>16.注意带标签的break会<strong>跳转到带标签的语句块末尾</strong>，标签必须紧贴循环或想跳出的语句，中间不要有其他的语句，</p><p>不然会报错；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">read :</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;<span class="number">10</span>;j++)&#123;</span><br><span class="line">        <span class="keyword">while</span>((i+j)&gt;<span class="number">5</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span> read;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>17.java中的[ ]运算符被预定义为会完成越界检查，而且没有指针运算，即<strong>不能通过类似a+1得到下一个元素</strong>；</p><h1 id="第四章-对象与类"><a href="#第四章-对象与类" class="headerlink" title="第四章 对象与类"></a>第四章 对象与类</h1><p>1、类之间，最常见的关系：依赖、聚合、继承。</p><p>如果一个类的方法使用或操纵另一个类的对象，我们就说一个类依赖与另一个类，我们应尽可能将相互依赖的类减至最少，</p><p>用术语说，就是减少耦合。</p><p>2、对象变量并没有实际包含一个对象，它只是引用一个对象，即地址。</p><p>3、<strong>所有的Java对象都储存在堆中，当一个对象包含另一个对象变量时，它只是包含另一个堆对象的指针。</strong></p><p>4、关于Date,会得到一个距离1970年1月1日的一个毫秒数；</p><p>​关于LocalDate，不能使用构造器构造它的对象，就是说不能new，应当LocalDate.now(),使用静态工厂方法，它会构造一个新的对象，输出日期；LocalDate.of(year,month,day)可以设置特定 日期的对象，还有一些相关方法，具体使用如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Date da=<span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        System.out.println(da);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(LocalDate.now());</span><br><span class="line">        LocalDate newYear= LocalDate.now();</span><br><span class="line">        System.out.println(newYear.getYear());</span><br><span class="line">        System.out.println(newYear.getMonthValue());</span><br><span class="line">        System.out.println(newYear.getDayOfMonth());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;---------------&quot;</span>);</span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">newoneNewY</span> <span class="operator">=</span> newYear.plusDays(<span class="number">365</span>);</span><br><span class="line">        System.out.println(newoneNewY.getYear());</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">Mon Sep <span class="number">06</span> 08:<span class="number">41</span>:<span class="number">35</span> CST <span class="number">2021</span></span><br><span class="line"><span class="number">2021</span>-09-<span class="number">06</span></span><br><span class="line"><span class="number">2021</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line">---------------</span><br><span class="line"><span class="number">2022</span></span><br></pre></td></tr></table></figure><p>5、只访问对象而不修改对象的方法称为访问器方法，会修改对象的称为更改器方法。</p><p>6、public数据字段允许程序中任何方法访问，这完全破坏了封装，因此，强烈建议将实例字段标记为private。</p><p>7、<strong>var关键字只能用于方法中的局部变量</strong>。</p><p>8、在每一个方法中，关键字this指示隐式参数，隐式参数没有出现在方法声明中；如果在构造器第一个语句是</p><p>this(参数)；这样的语句，那么运行到这里时就会调用另一个构造器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">(<span class="type">double</span> s)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//这里将调用Employee(String,double)构造器</span></span><br><span class="line">    <span class="built_in">this</span>(<span class="string">&quot;Employee #&quot;</span>+nextId,s);</span><br><span class="line">    nextId++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>9、关于static</p><p>- </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> nextId=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，如果创建1000个Employee对象，就有1000个实例字段id，但是只有一个nextId，就是说nextId被所有对象共享，</p><p>这个时候只要在一个对象上改变nextId的值，那么所有对象的nextId值都会变；</p><p>- </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Math</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">double</span> <span class="variable">PI</span> <span class="operator">=</span> <span class="number">3.14159265358979</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在程序中，建议直接Math.PI访问这个常量，如果省略static，PI就变成了实例字段，就必须要通过它的一个对象来访问PI；</p><p>- </p><p><strong>静态方法是不在对象上执行的方法，就是说应该用  类目.方法名   这样来使用。可以使用对象调用静态方法，这是合法的，</strong></p><p><strong>但建议使用类名。</strong></p><p><em><strong>静态方法不能访问实例字段，因为它不能在对象上执行操作，但是静态方法可以访问静态字段；</strong></em></p><p>- </p><p>静态方法还有一种用途，就是静态工厂方法，类通过这种方法来构造对象，而不是new。</p><p>可以调用静态方法而不需要任何对象，mian方法也是一个静态方法。</p><p>10、Java程序设计语言对对象采用的不是按引用调用，实际上，对象引用是按值传递的。</p><p>11、方法有相同的名字、不同的参数就出现了重载。<strong>方法名以及参数类型</strong>  叫做方法的签名，返回类型不是方法签名的一部分，就是说</p><p>方法重载不用看返回值类型。</p><p>12、</p><p>- </p><p>关于初始化块</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> nextId;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> salary;</span><br><span class="line">    </span><br><span class="line">    &#123;</span><br><span class="line">        id = nextId;</span><br><span class="line">        nextId++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">(String n,<span class="type">double</span> s)</span></span><br><span class="line">    &#123;</span><br><span class="line">        name = n;</span><br><span class="line">        salary = s;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，<strong>id字段都会在对象初始化中初始化，首先运行初始化块，然后才运行构造器的主体部分</strong>。但是通常会直接将初始化代码放在构造器中。建议将初始化块放在字段定义之后。</p><p>- </p><p>初始化静态字段的两种方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一种</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">nextId</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="comment">//第二种,如果类的静态字段需要很复杂的初始化代码，那就用这种</span></span><br><span class="line"><span class="keyword">static</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">var</span> <span class="variable">gen</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">    nextId = gen.nextId(<span class="number">10000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在类第一次加载的时候，会进行静态字段的初始化</strong>，所有的静态字段初始化方法以及静态初始化块都将依照类声明中出现的顺序进行。</p><p>13、Java会自动垃圾回收，所以不支持析构器。</p><p>14、不要使用finalize方法来完成清理，此方法已被废弃。</p><p>15、为了保证包名的绝对唯一性，要用一个因特网域名以逆序的形式作为包名。比如：域名horstmann.com,逆序得到包名</p><p>com.horstmann,后面再追加一个工程名，如com.horstmann.corejava,然后放入Employee类，就是com.horstmann.corejava.Employee,这就是我们熟悉的味道了。</p><p>16、嵌套的包之间没有任何的关系，每一个包都是一个独立的集合。</p><p>17、<strong>星号（*）只能导入一个包</strong>，注意不要发生命名冲突，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*</span><br><span class="line"><span class="keyword">import</span> java.sql.*</span><br></pre></td></tr></table></figure><p>这两个包里都有Date类，如果你这样使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Date today;</span><br></pre></td></tr></table></figure><p>会报错，因为它不知道要用哪一个包里的Date类，可以加一句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*</span><br><span class="line"><span class="keyword">import</span> java.sql.*</span><br><span class="line"><span class="keyword">import</span> java.util.Date</span><br></pre></td></tr></table></figure><p>如果都要使用，那就加上完整的包名：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">line</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">java</span>.util.Date();</span><br><span class="line"><span class="type">var</span> <span class="variable">today</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">java</span>.sql.Date(...);</span><br></pre></td></tr></table></figure><p>18、import可以导入静态方法和静态字段，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.System.*</span><br></pre></td></tr></table></figure><p>这样你就可以直接这样写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">exit(<span class="number">0</span>);</span><br><span class="line"><span class="comment">//不用加前缀</span></span><br></pre></td></tr></table></figure><p>19、编译器处理文件，而Java解释器加载类（带有 . 分隔符）。编译器在编译源文件时不检查目录结构，一个源文件，如果包与目录不匹配，虚拟机就找不到类，无法运行，但是如果它不依赖于其它包，就可以通过编译。</p><p>20、关于文档注释，请看：<a href="">https://www.cnblogs.com/boring09/p/4274893.html</a>；</p><p>21、关于idea中debug的使用，请看：<a href="">https://www.cnblogs.com/chiangchou/p/idea-debug.html</a>;</p><h1 id="第五章-继承"><a href="#第五章-继承" class="headerlink" title="第五章  继承"></a>第五章  继承</h1><p>1、在Java中，所有的继承都是公共继承，而没有C++中的私有继承和保护继承。</p><p>2、<strong>父类的对象不能使用子类的方法。</strong></p><p>3、字段一般是私有的，对于一个类来说，<strong>只有本类的方法才能访问本类的私有字段，即便是子类的方法也不能直接访问。</strong></p><p>4、如果想调用超类(父类)的方法，就：super.getSalary(),这样，用super关键字。</p><p>5、<strong>this是引用，super不是一个对象的引用，</strong>它只是一个指示编译器调用超类方法的特殊关键字。</p><p>this有两种用途：一是隐式参数的引用；二是调用本类的其它构造器。</p><p>super也有两种: 一是调用父类的方法；二是调用父类的构造器。</p><p>6、继承可以增加字段、增加方法、覆盖方法，但绝对不会删除任何字段或方法。</p><p>7、</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Manager</span><span class="params">(String name,<span class="type">double</span> salary,<span class="type">int</span> year,<span class="type">int</span> month,<span class="type">int</span> day)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">super</span>(name,salary,year,month,day);</span><br><span class="line">    bonus=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>像这样用super，会调用父类的构造器给父类的字段初始化，<strong>注意！使用super调用构造器的语句必须是子类构造器的第一条语句。</strong></p><p>8、如果子类构造器没有显示调用父类的构造器，将自动调用父类的无参构造器，如果父类没有无参的构造器，编译器会报一个错。</p><p>9、一个对象变量可以指示多种实际类型的现象称为多态。在运行时能够自动的选择合适的方法称为动态绑定。</p><p>10、子类的每个对象也是超类的对象，就比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Employee e;</span><br><span class="line">e = <span class="keyword">new</span> <span class="title class_">Employee</span>(...);</span><br><span class="line">e = <span class="keyword">new</span> <span class="title class_">Manager</span>(...);<span class="comment">//子类给父类对象</span></span><br></pre></td></tr></table></figure><p>但是，不能将超类引用赋给子类变量，如果确实想，就要强制类型转换。<em><strong>注意！只能在继承层次内进行强制类型转换；转换之前最好用instanceof检查一下。</strong></em></p><p><strong>在Java中，子类引用的数组可以转换成超类引用的数组，而不需要使用强制类型转换</strong>，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Manager[] managers = <span class="keyword">new</span> <span class="title class_">Manager</span>[<span class="number">10</span>];</span><br><span class="line"><span class="comment">//可以这样</span></span><br><span class="line">Employee[] staff = managers;</span><br></pre></td></tr></table></figure><p>11、返回类型不是签名的一部分，但是，允许子类将覆盖方法的返回类型改为原返回类型的子类型，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Employee <span class="title function_">getBuddy</span><span class="params">()</span>&#123;...&#125;</span><br><span class="line"><span class="comment">//这是父类Employee中的方法</span></span><br><span class="line"><span class="keyword">public</span> Manager <span class="title function_">getBuddy</span><span class="params">()</span>&#123;...&#125;</span><br><span class="line"><span class="comment">//这是子类的方法，注意到返回类型是原返回类型的子类型</span></span><br></pre></td></tr></table></figure><p>像这样的，<strong>我们说这两个方法有可协变的返回类型</strong>。</p><p>12、在覆盖一个方法的时候，子类方法不能低于超类方法的可见性。</p><p>13、final类中的所有方法自动的成为final方法，<strong>但是这不包括字段</strong>。</p><p>14、String类也是final类。</p><p>15、如果声明了protected，保护字段只能由同一个包中的类和它的所有子类访问。</p><p>16、</p><ul><li><p>仅对本类可见——private；</p></li><li><p>对外部完全可见——public；</p></li><li><p>对本包和所有子类可见——protected；</p></li><li><p>对本包可见——默认；</p><p><strong>注意默认和protected的区别！</strong></p></li></ul><p>17、object类中的equals方法会确定两个对象引用是否相等。</p><p>18、object类的hashcode方法默认从对象的存储地址得出散列码。注意！<strong>字符串的散列码是由内容导出的，有可能相等</strong>，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s=<span class="string">&quot;ok&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> t=<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line"><span class="comment">//它们的散列码是相等的</span></span><br></pre></td></tr></table></figure><p>19、要想<strong>打印多维数组，需要调用Arrays.deepToString方法</strong>。</p><p>20、使用集合，可以直接这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">staff</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Employee&gt;();</span><br></pre></td></tr></table></figure><p>21、trimToSize方法会把集合的大小调整为保存当前元素的存储空间。垃圾回收器会回收多余的存储空间。</p><p>22、ArrayList类不是Java程序设计语言的一部分，它只是由某个人编写并在标准库中提供的一个实用工具类。</p><p>23、将一个原始ArrayList赋给一个类型化的ArrayList会得到一个警告，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmployeeDB</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList <span class="title function_">find</span><span class="params">(String query)</span>&#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line">ArrayList&lt;Employee&gt; result = employeeDB.find(query);<span class="comment">//会报错</span></span><br></pre></td></tr></table></figure><p>但这个问题影响不了什么，我们还是想让它成功编译，就可以：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span>ArrayList&lt;Employee&gt; result = employeeDB.find(query);</span><br></pre></td></tr></table></figure><p>加上一个标签，关于这个标签，请看：<a href="https://www.cnblogs.com/chenmingjun/p/9027111.html">https://www.cnblogs.com/chenmingjun/p/9027111.html</a></p><p>24、装箱和拆箱是编译器要做的事，而不是虚拟机。</p><p>25、像这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Size</span>&#123;small,medium,large&#125;</span><br></pre></td></tr></table></figure><p>是枚举类型，<strong>它实际上是一个类</strong>，比较两个枚举类型的值时，直接使用“&#x3D;&#x3D;”就可以了，因为是类，所以可以加构造器和方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Size</span></span><br><span class="line">&#123;</span><br><span class="line">    small(<span class="string">&quot;s&quot;</span>),medium(<span class="string">&quot;m&quot;</span>),large(<span class="string">&quot;l&quot;</span>);</span><br><span class="line">    <span class="keyword">private</span> String abb;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Size</span><span class="params">(String abb)</span>&#123;<span class="built_in">this</span>.abb = abb;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>枚举的构造器必须是private的，不然会报错，所有的枚举类型都是Enum的子类。</strong></p><p>26、获取Class对象的三种方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一种</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">cl</span> <span class="operator">=</span> e.getClass();</span><br><span class="line"><span class="comment">//第二种</span></span><br><span class="line"><span class="type">String</span> <span class="variable">forname</span> <span class="operator">=</span> <span class="string">&quot;java.util.Random&quot;</span>;</span><br><span class="line"><span class="type">Class</span> <span class="variable">cl</span> <span class="operator">=</span> Class.forName(forname);</span><br><span class="line"><span class="comment">//第三种</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">cl</span> <span class="operator">=</span> <span class="type">int</span>.class;</span><br></pre></td></tr></table></figure><p>关于Class的方法：</p><ul><li><p>getName():会得到类名，如果类在包里，包的名字也作为类名的一部分；</p></li><li></li><li><ul><li><table><thead><tr><th><code>getConstructor(类&lt;?&gt;... parameterTypes)</code></th><th>返回一个 <code>构造器</code>对象，该对象反映此 <code>类</code>对象所表示的类的指定公共构造函数。</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table></li></ul></li><li><ul><li><table><thead><tr><th><code>字段[]</code></th><th><code>getFields()</code></th><th>返回一个包含 <code>字段</code>对象的数组， <code>字段</code>对象反映此  <code>类</code>对象所表示的类或接口的所有可访问公共字段。</th></tr></thead><tbody><tr><td></td><td></td><td></td></tr></tbody></table></li></ul></li></ul><p>getFields返回包含Field对象的数组，这些对象对应这个类或其超类的公共字段</p><ul><li><ul><li><table><thead><tr><th><code>字段[]</code></th><th><code>getDeclaredFields()</code></th><th>返回 <code>字段</code>对象的数组， <code>字段</code>对象反映由此  <code>类</code>对象表示的类或接口声明的所有字段。</th></tr></thead><tbody><tr><td></td><td></td><td></td></tr></tbody></table></li></ul></li></ul><p>这个只返回包含Field对象的数组，但是只是此类的。</p><p>同样的还有getMethods、getDeclareMethods和getConstructors、getDeclareConstructors</p><ul><li><ul><li><table><thead><tr><th><code>类&lt;?&gt;</code></th><th><code>getComponentType()</code></th><th>返回表示数组的组件类型的 <code>类</code> 。</th></tr></thead><tbody><tr><td></td><td></td><td></td></tr></tbody></table></li></ul></li></ul><p><strong>这个方法可以确定数组的正确类型，会返回一个Class类型的对象。</strong></p><p>27、异常有两种类型：非检查型异常和检查型异常。<strong>越界错误或者访问null引用都属于非检查型异常。</strong></p><p>28、Java 的lang包下有三个类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java.lang.reflect.Field;</span><br><span class="line">java.lang.reflect.Method;</span><br><span class="line">java.lang.reflect.Constructor;</span><br></pre></td></tr></table></figure><ul><li>int getModifiers()</li></ul><p>这三个类都有的方法，返回一个整数（0&#x2F;1），描述的是构造器、方法或者字段的修饰符。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可以这样使用，就能输出修饰符</span></span><br><span class="line"><span class="type">String</span> <span class="variable">modifiers</span> <span class="operator">=</span> Modifier.toString(cl.getModifiers());</span><br><span class="line"><span class="comment">//cl是一个class对象</span></span><br></pre></td></tr></table></figure><ul><li>String getName()</li></ul><p>返回一个表示构造器名、方法名、字段名的字符串。</p><ul><li>Class[] getParameterTypes()   (在Constructor和Method classes 类中)</li></ul><p>返回一个对象数组，其中各个对象表示参数的类型。</p><ul><li>Class getReturnType()  (在Method类中)</li></ul><p>返回一个表示返回类型的Class对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.reflect.Modifier</span><br></pre></td></tr></table></figure><ul><li>static String toString(int modifiers)</li></ul><p>返回字符串，表示修饰符</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.reflect.Array</span><br></pre></td></tr></table></figure><ul><li>newInstance(componentType,newLength)</li></ul><p><strong>这个方法可以构造一个新的数组，两个参数，一个是数组的元素类型，一个是数组长度</strong></p><p>29、<strong>Employee[] 数组可以转换为Object[] 数组，但不能反过来，就是说不能强制类型转换，</strong>如果反过来，虚拟机会报异常。</p><p>Employee[]数组临时转换成Object[]数组，然后再换回来是可以的，但一个一开始就是Object[]的数组永远不能转换为Employee[]数组，</p><p><strong>整型数组int[]可以转化成object，但不能转化成对象数组，即object[]。</strong></p><h1 id="第六章-接口、lambda表达式与内部类"><a href="#第六章-接口、lambda表达式与内部类" class="headerlink" title="第六章  接口、lambda表达式与内部类"></a>第六章  接口、lambda表达式与内部类</h1><p>1、Arrays类中的sort方法可以对对象数组进行排序，但前提是对象所属的类必须实现了Comparable接口；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Comparable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Object other)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、接口中的所有方法默认是public的，但是也可以是其它的;</p><p>3、在调用：x.compareTo(y)的时候，当x小于y是，返回一个负数；相等时，返回0；否则返回一个正数；</p><p>4、接口绝对不会有实例字段，提供实例字段和方法实现的任务应该由实现接口的那个类来完成；</p><p>5、现在希望对员工薪水进行排序，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Employee&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Employee other)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> Double.compare(salary,other.salary);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6、大多数情况下，当x.equals(y)时x.compareTo(y)就应该等于0，但是有一个例外：BigDecimal,</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x=<span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1.0&quot;</span>);</span><br><span class="line">y=<span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1.00&quot;</span>);</span><br><span class="line">x.equals(y);</span><br><span class="line"><span class="comment">//结果是false，因为两个数的精度不同</span></span><br><span class="line">x.compareTo(y);</span><br><span class="line"><span class="comment">//结果是0</span></span><br></pre></td></tr></table></figure><p>7、为什么不把Comparable直接设计成一个抽象类？然后需要的时候就重写一下compareTo方法使用？</p><p>注意一个类只能继承一个类，而却可以实现多个接口，如果继承了这个类，那么它就不能继承其它类了。</p><p>8、允许在接口中增加静态方法，但是，当一个类实现了这个接口，并且生成了一个对象，不能用对象去访问这个静态方法，就是不能 对象.方法 这样访问，必须要使用  接口名.方法  这样访问，并且静态方法不用重写。</p><p>9、允许接口方法是private的。private方法可以是静态方法或实例方法，私有方法只能在接口本身的方法中使用；</p><p>10、接口中有一个默认方法，修饰符为：default，默认方法不需要重写，当然想重写也是可以的，默认方法最重要的是可以使接口演化，就是说：假如有一个类或很多类实现了一个接口，突然有一天你发现想多增加一个方法给接口，但这就意味着你需要在所有实现了这个接口的类中去重写这个方法，太麻烦了。这个时候可以将那个增加的方法前加 default，就不用重写了，编译也不会报错。</p><p>​那么，问题来了：如果先在一个接口中定义了一个默认方法，然后又在另一个接口或者超类中定义同样的方法，这会怎么样呢？</p><p>三点：</p><ul><li>超类优先。如果超类有一个具体方法，那么同名并且有相同参数类型的默认方法会被忽略；</li><li>接口冲突。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">default</span> String <span class="title function_">getName</span><span class="params">()</span>&#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Named</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">default</span> String <span class="title function_">getName</span><span class="params">()</span>&#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//一个类实现了这两个接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Person</span>,Named&#123;...&#125;</span><br></pre></td></tr></table></figure><p>像这样，类会继承两个接口提供的不一致的方法，并不是选择一个，编译器会报一个错误，解决方法：</p><p>在Student中加一个getName方法，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Person</span>,Named</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> Person.<span class="built_in">super</span>.getName();</span><br><span class="line">        <span class="comment">//这个时候就会调用Person接口的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，如果一个是默认的，一个没有默认呢？</p><p>这个时候，只要有一个是默认的，编译器就会报错，程序员必须解决这个二义性。</p><p>那么，如果两个都没默认呢？</p><p>那它们就是普通的接口方法，要么重写，要么把类变成抽象类。</p><p>11、注意！！！不要让一个默认方法重新定义Object类的方法，会失败。因为类优先原则，即“超类优先。如果超类有一个具体方法，那么同名并且有相同参数类型的默认方法会被忽略”；</p><p>12、标记接口：不包含任何方法；它唯一的作用就是允许在类型查询中使用instanceof，建议不要使用标记接口，比如 Cloneable就是标记接口；</p><p>13、</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(String first,String second) -&gt; &#123;first.length() - second.length();&#125;</span><br></pre></td></tr></table></figure><p>这就是lambda表达式；</p><p>14、如果小括号的参数类型可以推导出来，就可以省略，小括号中可以没有参数，如果小括号中只有一个参数，那么小括号可以忽略；</p><p>如果大括号只有一条输出语句，大括号可以忽略，分号也可以省略，如果有return的话，return也可以省略；</p><p>15、使用lambda表达式的前提：</p><ul><li>一个接口；</li><li>接口中有且只有一个抽象方法；</li></ul><p>这样的接口称为函数式接口，<strong>就是说，如果想要调用一个方法，然后这个方法的某个参数是一个函数式接口，那么你就可以直接传一个</strong></p><p><strong>lambda表达式过去</strong>。比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(words,(first,second)-&gt;first.length()-second.length());</span><br></pre></td></tr></table></figure><p>​<strong>在底层，方法会接收实现了Comparator<String>这个接口的某个类的对象，然后在这个对象上调用compare方法执行这个lambda表达式</strong>。</p><p>16、不能把lambda表达式赋给类型为Object类型的变量，它不是函数式接口；</p><p>17、注意java.util.function包有一个非常重要的接口Predicate：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Predicate</span>&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(T t)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个接口专门用来传递lambda表达式，比如removeIF方法，它的参数就是Predicate，可以直接：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.removeIf(e -&gt; ==<span class="literal">null</span>);</span><br></pre></td></tr></table></figure><p>还有一个接口Supplier<T>:这个可以实现懒计算；</p><p>18、关于<strong>方法引用</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">timer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Timer</span>(<span class="number">1000</span>,System.out::println);</span><br></pre></td></tr></table></figure><p>表达式System.out::println是方法引用，<strong>它指示编译器生成一个函数式接口的实例，覆盖这个接口的抽象方法来调用给定的方法</strong>。</p><p>与lambda表达式一样，方法引用也不是一个对象。但是，<strong>为一个类型为函数式接口的变量赋值时会生成一个对象。</strong></p><p>19、有些方法引用和lambda表达式是等价的，可以互相重写。注意！只有当lambda表达式的体只调用一个方法而不做其它操作时，才能把lambda表达式重写为方法引用，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s -&gt; s.length() == <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>这里有一个方法调用，但还有一个比较，所以不能使用方法引用。</p><p>20、<strong>方法引用不能独立存在，总是会转化为函数式接口的实例</strong>；</p><p>21、可以在方法引用中使用this、super参数；</p><p>22、关于构造器引用：</p><p>与方法引用类似，只不过方法名为new，比如：Person：：new是Person构造器的一个引用。</p><p>可以用数组类型建立构造器引用，比如：int[]::new是一个构造器引用，它有一个参数，即数组的长度，相当于lambda表达式的：</p><p>x -&gt; new int[x];</p><p>23、lambda表达式可以方法访问外围方法或类中的变量，准确来说应该是捕获，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">repeatMessage</span><span class="params">(String text,<span class="type">int</span> delay)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">ActionListener</span> <span class="variable">listener</span> <span class="operator">=</span> event -&gt;</span><br><span class="line">        &#123;</span><br><span class="line">        System.out.println(text);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Timer</span>(delay,listener).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，text被表达式捕获，会被复制，捕获的变量必须是事实最终变量，就是说这个变量初始化后就不会再为它赋值，比如这样的都是不合法的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">repeatMessage</span><span class="params">(String text,<span class="type">int</span> delay)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">ActionListener</span> <span class="variable">listener</span> <span class="operator">=</span> event -&gt;</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="comment">//text会改变，不可以</span></span><br><span class="line">        System.out.println(text--);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Timer</span>(delay,listener).start();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//上面是在lambda表达式里面改变，变量在外面改变也不可以</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">repeatMessage</span><span class="params">(String text,<span class="type">int</span> delay)</span></span><br><span class="line">&#123;</span><br><span class="line">    text--;</span><br><span class="line">    <span class="type">ActionListener</span> <span class="variable">listener</span> <span class="operator">=</span> event -&gt;</span><br><span class="line">        &#123;</span><br><span class="line">        System.out.println(text);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Timer</span>(delay,listener).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>24、lambda表达式的体与嵌套块有相同的作用域，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">ActionListener</span> <span class="variable">listerner</span> <span class="operator">=</span> event -&gt; </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">this</span>.toString();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的this调用的是Application的toString方法；</p><p>25、使用lambda表达式的重点是延迟执行；</p><p>26、内部类中声明的所有静态字段都必须是final、内部类不能有static方法；</p><p>26、匿名内部类不能有构造器；</p><h1 id="第七章-异常、断言和日志"><a href="#第七章-异常、断言和日志" class="headerlink" title="第七章  异常、断言和日志"></a>第七章  异常、断言和日志</h1><p>1、异常处理的任务就是将控制权从产生错误的地方转移到能够处理这种情况的异常处理器；</p><p>2、所有的异常都是由Throwable继承而来；</p><p>3、Error类层次结构描述Java运行时系统的内部错误和资源耗尽错误。如果出现这种错误，你几乎无能为力。</p><p>4、RuntimeException异常包括：</p><ul><li><p>错误的强制类型转换；</p></li><li><p>数组访问越界；</p></li><li><p>访问null指针；</p><p>不是派生于RuntimeException的异常包括：</p></li><li><p>试图超越文件末尾继续读取数据；</p></li><li><p>试图打开一个不存在的文件；</p></li><li><p>试图根据给定的字符串查找Class对象，而这个字符串表示的类不存在；</p></li></ul><p>5、派生于Error类或者RuntimeException类的所有异常都称为非检查型异常，其它的异常称为检查型异常。编译器将检查你是否为所有的检查型异常提供了异常处理器；</p><p>6、</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">FileInputStream</span><span class="params">(String name)</span> <span class="keyword">throws</span> FileNotFoundException</span><br></pre></td></tr></table></figure><p>流程:将会根据给定的name生成一个FileInputStream对象，如果出错，则抛出一个FileNotFoundException对象，然后系统开始搜索FileNotFoundException对象的异常处理器，如果没有异常处理器处理这个异常，当前执行的线程就会终止；</p><p>7、如果一个方法有可能抛出多个检查型异常，那么就必须在方法的首部列出所有的异常类。每个异常类之间用逗号隔开。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">My</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Image <span class="title function_">loadImage</span><span class="params">(String s)</span> <span class="keyword">throws</span> FileNotFoundException,EOFException</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是不需要声明非检查型异常；</p><p>8、如果在子类中覆盖了超类的一个方法，子类方法中声明的检查型异常不能比超类方法中声明的异常更通用，就是说超类中的异常类应该是父类，注意！如果超类方法没有抛出任何检查型异常，子类也不能抛出任何检查型异常；</p><p>9、定义自己的异常类：这个类应该派生于Exception，或者派生于它的某个子类；这个类应当有两个构造器，一个是默认的构造器，另一个是包含详细描述信息的构造器（超类Throwable的toString方法会返回一个字符串，其中包含详细信息）；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FileFormatException</span> <span class="keyword">extends</span> <span class="title class_">IOException</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FileFormatException</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FileFormatException</span><span class="params">(String gripe)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">super</span>(gripe);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>10、要想捕获一个异常，需要设置try&#x2F;catch语句块；</p><p>11、如果try语句块中的任何代码抛出了catch子句中的一个异常类，那么程序将跳过try语句块中的其余代码，然后执行catch中的处理器代码；如果try语句块中的代码没有抛出任何异常，那么程序将跳过catch字句；如果方法中的任何代码抛出了catch子句中没有声明的一个异常类型，那么方法就会立即退出；</p><p>12、如果调用了一个会抛出检查型异常的方法，就必须处理这个异常，或者继续传递这个异常；</p><p>13、什么时候捕获，什么时候传递呢？一般经验：捕获你自己知道怎么处理的异常，传递你不知道怎么处理的异常；</p><p>14、如果编写一个方法覆盖超类的方法，而超类方法没有抛出异常，那么子类就必须捕获方法中出现的每一个检查型异常。不允许在子类的throws说明符中出现超类方法未列出的异常类；</p><p>15、同一个catch子句中可以捕获多个异常类型，只有当捕获的异常类型彼此之间不存在子类关系时才可以用；注意！！捕获多个异常时，异常变量默认是final的，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">catch</span>(FileNotFoundException | UnKnownHostException e)&#123;...&#125;</span><br></pre></td></tr></table></figure><p>16、可以在catch中抛出一个异常。通常，希望改变异常类型时会这样做。</p><p>17、关于finally子句：清理资源。不管是否有异常被捕获，finally子句的代码都会执行；try语句可以只有finally子句，而没有catch；不要把改变控制流的语句（return、throw、break、continue）放在finally子句中；</p><p>18、关于try-with-Resources语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是最简形式</span></span><br><span class="line"><span class="keyword">try</span>(Resource res=...)</span><br><span class="line">&#123;</span><br><span class="line">    work with res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>try块退出或者存在异常时，会自动调用res.close()。就是关闭了资源，就好像使用了finally块一样。try后面的括号里可以使用之前声明的事实最终变量。</p><p>19、只要需要关闭资源，就要尽可能的使用try-with-Resources语句；</p><p>20、try-with-Resources语句自身也可以有catch子句，甚至还可以有一个finally子句。这些子句会在关闭资源后执行；</p><p>21、处理异常应该遵循：早抛出，晚捕获；</p><p>22、在默认情况下，断言是禁用的。可以用-enableassertions或者-ea启用断言</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -enablebleassertions MyApp</span><br></pre></td></tr></table></figure><p>可以用-disableassertions或者-da禁用断言；、</p><p>23、启用或者禁用断言是类加载器的功能。禁用断言时，类加载器会去除断言代码；</p><p>24、Java中，有三种处理系统错误的机制：</p><ul><li>抛出一个异常；</li><li>日志；</li><li>使用断言；</li></ul><p>25、注意！！</p><ul><li><p>断言失败是致命的、不可恢复的错误；</p></li><li><p>断言检查只是在开发和测试阶段打开；</p><p>因此，不应该使用断言向程序的其它部分通知发生了可恢复性的错误，或者，不应该利用断言与程序用户沟通问题。断言只应该用于在测试阶段确定程序内部错误的位置。</p></li></ul><h1 id="第八章-泛型程序设计"><a href="#第八章-泛型程序设计" class="headerlink" title="第八章  泛型程序设计"></a>第八章  泛型程序设计</h1><p>1、泛型类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pair</span>&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Pair</span><span class="params">()</span>&#123;first = <span class="literal">null</span>;&#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getFirst</span><span class="params">()</span>&#123;<span class="keyword">return</span> first;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFirst</span><span class="params">(T newvalue)</span>&#123;first = newvalue;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>泛型类可以有多个类型变量，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pair</span>&lt;T,U&gt;&#123;...&#125;</span><br></pre></td></tr></table></figure><p>2、泛型方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Array</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">getMiddle</span><span class="params">(T...a)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> a[a.length / <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意！类型变量放在修饰符（这里的修饰符就是public static）的后面，并在返回类型的前面；</p><p>注意参数a 的类型必须是T；</p><p>3、泛型方法可以在普通类中定义，也可以在泛型类中定义；</p><p>4、调用泛型方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">mid</span> <span class="operator">=</span> Array.&lt;String&gt;getMiddle(<span class="string">&quot;John&quot;</span>,<span class="string">&quot;public&quot;</span>);</span><br><span class="line"><span class="comment">//也可以这样</span></span><br><span class="line"><span class="type">String</span> <span class="variable">mid</span> <span class="operator">=</span> Array.getMiddle(<span class="string">&quot;John&quot;</span>,<span class="string">&quot;public&quot;</span>);</span><br></pre></td></tr></table></figure><p>注意参数类型都是String的，如果不同，就会去找它们共同的超类；</p><p>5、关于通配符：</p><ul><li>extends：这是上限，比如：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T entends Comparable&gt;T <span class="title function_">min</span><span class="params">(T[] a)</span></span><br></pre></td></tr></table></figure><p>现在，泛型方法min只能在实现了Comparable接口的类上调用；</p><p>6、类型变量可以有多个限定：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T <span class="keyword">extends</span> <span class="title class_">Comparable</span> &amp; Serializable</span><br></pre></td></tr></table></figure><p>限定类型用 &amp; 分隔，用逗号来分隔类型变量；</p><p>7、在Java继承中，可以实现多个接口，但最多有一个限定可以是类。如果有一个类作为限定，它必须是限定列表中的第一个限定；</p><p>8、关于类型擦除：虚拟机没有泛型类型对象——所有对象都属于普通类；无论何时定义一个泛型类型，都会自动提供一个相应的原始类型，这个原始类型就是擦除后的类型。</p><p>9、原始类型用第一个限定来替换类型变量，如果没有限定，就替换为Object，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Inter</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span> &amp; Serializable&gt; <span class="keyword">implements</span> <span class="title class_">Serializable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> T l;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Inter</span><span class="params">(T l)</span>&#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//原始类型如下</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Inter</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Comparable l;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Inter</span><span class="params">(Comparable l)</span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>10、为了提高效率，应该将标签接口（即没有方法的接口）放在限定列表的末尾；</p><p>11、注意！！类型擦除与多态发生了冲突，为了解决这个问题，编译器会生成一个桥方法；桥方法不仅用于泛型类型；</p><p>12、对于Java泛型转换：</p><ul><li>虚拟机中没有泛型，只有普通类和方法；</li><li>所有的类型参数都会替换为它们的限定类型；</li><li>会合成桥方法来保持多态；</li><li>为了保持安全性，必要时会插入强制类型转换；</li></ul><p>13、关于泛型的的限制与局限性：</p><ul><li>不能用基本类型实例化类型参数；</li></ul><p>就是说不能是double，必须要是Double；</p><ul><li>运行时类型查询只适用于原始类型；</li></ul><p>如果试图查询一个对象是否属于某个泛型类型，你会得到一个编译器错误，或者得到一个警告，比如用getClass方法总是返回原始类型；</p><ul><li>不能创建参数化类型的数组；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">table</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;String&gt;[<span class="number">10</span>];</span><br><span class="line"><span class="comment">//这是错的</span></span><br><span class="line"><span class="comment">//擦除之后就会变成Pair[],这时候我们转换一下</span></span><br><span class="line">Object[] a = table;</span><br><span class="line"><span class="comment">//数组会记住它的元素类型，比如这样</span></span><br><span class="line">a[<span class="number">0</span>] = <span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="comment">//会报错，但是泛型不会，原因就是因为擦除，比如</span></span><br><span class="line">a[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;Employee&gt;();</span><br><span class="line"><span class="comment">//擦除之后就变成了 new Pair(),所有能够通过检查，但是仍然会有一个类型错误</span></span><br><span class="line"><span class="comment">//所以不能这样创建数组</span></span><br></pre></td></tr></table></figure><p>注意！！声明类型为Pair<String>[]的变量是合法的，但是不能用new Pair<String>[10]来初始化；</p><ul><li>不能实例化类型变量</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Pair</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">first = <span class="keyword">new</span> <span class="title class_">T</span>();</span><br><span class="line">    <span class="comment">//这是错的，擦除之后T就变成了Object</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>不能构造泛型数组</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">T[] m = <span class="keyword">new</span> <span class="title class_">T</span>[<span class="number">2</span>];</span><br><span class="line"><span class="comment">//这是错的</span></span><br></pre></td></tr></table></figure><ul><li>泛型类的静态上下文中类型变量无效</li></ul><p>就是说不能在静态字段或者方法中引用类型变量T；</p><ul><li><p>不能抛出或者捕获泛型类的实例；</p></li><li><p>可以取消对检查型异常的检查；</p></li><li><p>倘若两个接口类型是同一接口的不同参数化，一个类或者类型变量就不能同时作为这两个接口类型的子类；</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Employee&gt;&#123;...&#125;</span><br><span class="line">clsss Manger <span class="keyword">extends</span> <span class="title class_">Employee</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Manger&gt;&#123;...&#125;</span><br><span class="line"><span class="comment">//这是错的，可能会与桥方法产生冲突</span></span><br></pre></td></tr></table></figure><p>14、注意！！无论S和T有什么关系，Pair<S>与Pair<T>都没有任何关系，就是说Pair<Manger>不是Pair<Employee>的子类；</p><p>15、</p><ul><li>Pair&lt;? extends Employee&gt;</li></ul><p>上限，表示任何泛型Pair类型，它的参数类型是它自己或Employee的子类；</p><ul><li>Pair&lt;? super Manger&gt;</li></ul><p>下限，表示它的参数类型是它及它的父类；</p><p>16、通配符不是类型变量，就是说“？”这个不是一种类型；</p>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法笔记</title>
      <link href="/2023/02/18/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
      <url>/2023/02/18/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-%E8%93%9D%E6%A1%A5%E6%9D%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="1、八大排序"><a href="#1、八大排序" class="headerlink" title="1、八大排序"></a>1、八大排序</h2><h3 id="一、选择排序"><a href="#一、选择排序" class="headerlink" title="一、选择排序"></a>一、选择排序</h3><p>思路：每次选出剩余数据中最小的数据，和剩余数据第一位置的数据进行交换。</p><p><img src="C:\Users\jyj123\AppData\Roaming\Typora\typora-user-images\image-20221009230223597.png" alt="image-20221009230223597"></p><p>时间复杂度及分析</p><p>数组总大小为N</p><p>1、0-N-1范围内，选出最小的一个数放到0位置，要一个一个查看数组数据，需要n-1次；</p><p>2、1-N-1范围内，同上，选最小，需要n-2次；</p><p>……</p><p>次数相加：n-1 + n-2 + n-3 + … 这是一个<strong>等差数列</strong>，根据公式，最后一定是有平方项的，所以时间复杂度为<strong>O(n^2).</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> day1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 选择排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Code01_SelectionSort</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">SelectionSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line"><span class="comment">//先判断终止条件</span></span><br><span class="line"><span class="comment">//第一次，0-N-1个数，找出最小的，将这个数放到0位置上；</span></span><br><span class="line"><span class="comment">//第二次，1-N-1个数，找出最小的，将这个数放到1位置上；</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">if</span>(arr == <span class="literal">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; arr.length - <span class="number">1</span>;i++) &#123;<span class="comment">//注意这里是 长度-1 ，代表右边只剩下最后一个数据时，不需要再选了</span></span><br><span class="line"><span class="type">int</span> <span class="variable">minIndex</span> <span class="operator">=</span> i;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i+<span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">minIndex = arr[j] &lt; arr[minIndex] ? j : minIndex;</span><br><span class="line">&#125;</span><br><span class="line">swap(arr,i,minIndex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr,<span class="type">int</span> i,<span class="type">int</span> j)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">arr[i] = arr[j];</span><br><span class="line">arr[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">4</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">21</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">9</span>,<span class="number">8</span>&#125;;</span><br><span class="line">SelectionSort(arr);</span><br><span class="line">System.out.print(Arrays.toString(arr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="二、冒泡排序"><a href="#二、冒泡排序" class="headerlink" title="二、冒泡排序"></a>二、冒泡排序</h3><p><img src="C:\Users\jyj123\AppData\Roaming\Typora\typora-user-images\image-20221009230704177.png" alt="image-20221009230704177"></p><p>时间复杂度分析</p><p>每一趟只能确定一个数，然后下一趟就是 上一趟数-1 ，分析同选择排序，得到的也是一个等差数列，时间复杂度为<strong>O(n^2)</strong>.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> class01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Code02_BubbleSort</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0 ~ N-1</span></span><br><span class="line"><span class="comment">// 0 ~ N-2</span></span><br><span class="line"><span class="comment">// 0 ~ N-3</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">e</span> <span class="operator">=</span> arr.length - <span class="number">1</span>; e &gt; <span class="number">0</span>; e--) &#123; <span class="comment">// 0 ~ e</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; e; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (arr[i] &gt; arr[i + <span class="number">1</span>]) &#123;</span><br><span class="line">swap(arr, i, i + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换arr的i和j位置上的值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">arr[i] = arr[i] ^ arr[j];</span><br><span class="line">arr[j] = arr[i] ^ arr[j];</span><br><span class="line">arr[i] = arr[i] ^ arr[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>关于异或计算（不建议使用，比较取巧）</p><p>异或：不同为1；相同为0</p><p>1、0 ^ N &#x3D; N  ; N ^ N &#x3D;0</p><p>2、异或计算符合交换律a ^ b&#x3D;b ^ a、结合律(a ^ b) ^ c &#x3D; a ^ (b ^ c)；</p><p>3、（N1^N2^N3^…..)^N  由2可知，括号里面的数异或的顺序并不影响最终的结果；</p><p><strong>使用异或运算进行交换的前提：两个数所在的内存区域位置不能相同，一旦相同，就相当于自己和自己异或，会将那一内存区域的值抹成0.</strong></p><h3 id="三、插入排序"><a href="#三、插入排序" class="headerlink" title="三、插入排序"></a>三、插入排序</h3><p>思路：跟抓牌差不多，抓到牌从最后面往前看，逐渐比较，然后找到合适的位置就插入。从0开始递增，每一个数和它之前的数进行比较，比它前一个数小进行交换，然后停止，进行下一个数的排序。</p><p>与所给的数据情况相关。如果数据是有序的，那么时间复杂度：O(n) ；如果数据是无序的，每次后一个数据都需要与前面的数据进行交换，那么就是一个等差数列，时间复杂度：O(n^2) .</p><p>时间复杂度：O(n^2) ；额外空间复杂度：O(1).</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> class01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Code03_InsertionSort</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">insertionSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不只1个数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123; <span class="comment">// 0 ~ i 做到有序</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; arr[j + <span class="number">1</span>]; j--) &#123;</span><br><span class="line">swap(arr, j, j + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// i和j是一个位置的话，会出错</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">arr[i] = arr[i] ^ arr[j];</span><br><span class="line">arr[j] = arr[i] ^ arr[j];</span><br><span class="line">arr[i] = arr[i] ^ arr[j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="四、归并排序"><a href="#四、归并排序" class="headerlink" title="四、归并排序"></a>四、归并排序</h3><p>思路：先分后合。</p><p>例：【3 2 5 7 5 8】数组，将数组分为【3 2 5】【7 5 8】，先使这两个数组有序，变为【2 3 5】【5 7 8】，然后借助一个新数组，将这两个数组的数据存入到一个新数组中，即【2 3 5 5 7 8】。大概思路就是这样。</p><p>那么，怎么存入到新数组中呢？</p><p>两个下标分别指向两个有序数组起始位置，如果值，前小于后，那么将前的值存入新数组，并将前的下标++，同理，后也是一样。注意，下标不能越界。</p><p>当有一个下标到达边界后，就将另一个数组后面的全部数值填进新数组中。</p><p>这就是合的过程。</p><p>最后，将新数组中的值一一填回去就完成了。</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> class04;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Code01_MergeSort</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归方法实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mergeSort1</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">process(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请把arr[L..R]排有序</span></span><br><span class="line"><span class="comment">// l...r N</span></span><br><span class="line"><span class="comment">// T(N) = 2 * T(N / 2) + O(N)</span></span><br><span class="line"><span class="comment">// O(N * logN)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> L, <span class="type">int</span> R)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (L == R) &#123; <span class="comment">// base case</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> L + ((R - L) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">process(arr, L, mid);</span><br><span class="line">process(arr, mid + <span class="number">1</span>, R);</span><br><span class="line">merge(arr, L, mid, R);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> L, <span class="type">int</span> M, <span class="type">int</span> R)</span> &#123;</span><br><span class="line"><span class="type">int</span>[] help = <span class="keyword">new</span> <span class="title class_">int</span>[R - L + <span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> L;</span><br><span class="line"><span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> M + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (p1 &lt;= M &amp;&amp; p2 &lt;= R) &#123;</span><br><span class="line">help[i++] = arr[p1] &lt;= arr[p2] ? arr[p1++] : arr[p2++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 要么p1越界了，要么p2越界了</span></span><br><span class="line"><span class="keyword">while</span> (p1 &lt;= M) &#123;</span><br><span class="line">help[i++] = arr[p1++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (p2 &lt;= R) &#123;</span><br><span class="line">help[i++] = arr[p2++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; help.length; i++) &#123;</span><br><span class="line">arr[L + i] = help[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非递归方法实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mergeSort2</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> arr.length;</span><br><span class="line"><span class="comment">// 步长</span></span><br><span class="line"><span class="type">int</span> <span class="variable">mergeSize</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (mergeSize &lt; N) &#123; <span class="comment">// log N</span></span><br><span class="line"><span class="comment">// 当前左组的，第一个位置</span></span><br><span class="line"><span class="type">int</span> <span class="variable">L</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (L &lt; N) &#123;</span><br><span class="line"><span class="keyword">if</span> (mergeSize &gt;= N - L) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">M</span> <span class="operator">=</span> L + mergeSize - <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">R</span> <span class="operator">=</span> M + Math.min(mergeSize, N - M - <span class="number">1</span>);</span><br><span class="line">merge(arr, L, M, R);</span><br><span class="line">L = R + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 防止溢出</span></span><br><span class="line"><span class="keyword">if</span> (mergeSize &gt; N / <span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">mergeSize &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么归并排序可以做到O(N * logN)？</p><p>答：因为它没有浪费之前的比较过程，每一次的merge，都是两个有序的部分在merge，而选择、冒泡、插入排序都会浪费之前的比较过程，每次都只能确定一个值，这就是归并排序可以做到O(N * logN)的关键。</p><h3 id="五、快速排序"><a href="#五、快速排序" class="headerlink" title="五、快速排序"></a>五、快速排序</h3><p>快速排序应当要联想到荷兰国旗问题。</p><p>下面就是荷兰国旗问题的规律，目的就是让&lt;num的在左边，&#x3D;num的在中间，&gt;num的在右边。是通过不断的扩充左边界和右边界来实现的。</p><p><img src="C:\Users\jyj123\AppData\Roaming\Typora\typora-user-images\image-20230215203116730.png" alt="image-20230215203116730"></p><p>快排1.0</p><p>选取最后一个值，作为num。然后执行荷兰国旗问题过程，这样可以排好一个数，并将原数组分为左区域和右区域，之后在左区域和右区域递归此过程就可以了。每次都有一个数排好。最后有序。</p><p>快排2.0</p><p>相比1.0，2.0就是每次排一个数的时候可以排好一批和num相等的数，其它不变。</p><p>1.0和2.0最差情况都是O(N^2)，因为选取最后一个为划分值可能打的很偏，就是分离数组，有可能只有左边界，也有可能只有右边界，这样每次就只能确定一个值，就退化为O(N^2)的算法；如果在中间，理想情况，那么就是O(N * logN)的算法。</p><p>快排3.0</p><p>3.0解决了1、2划分值可能会打偏的问题，解决方法，从数组中随机选取一个数作为划分值，这样就变成了等概率事件，每一种情况都是等概率的，对每一种情况用master公式分析，得出每一种情况的时间复杂度，最后求数学上的长期期望，最终结果：快排3.0时间复杂度为O(N * logN)。</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> class05;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Code03_QuickSortRecursiveAndUnrecursive</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 荷兰国旗问题</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] netherlandsFlag(<span class="type">int</span>[] arr, <span class="type">int</span> L, <span class="type">int</span> R) &#123;</span><br><span class="line"><span class="keyword">if</span> (L &gt; R) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] &#123; -<span class="number">1</span>, -<span class="number">1</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (L == R) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] &#123; L, R &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">less</span> <span class="operator">=</span> L - <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">more</span> <span class="operator">=</span> R;</span><br><span class="line"><span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> L;</span><br><span class="line"><span class="keyword">while</span> (index &lt; more) &#123;</span><br><span class="line"><span class="keyword">if</span> (arr[index] == arr[R]) &#123;</span><br><span class="line">index++;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[index] &lt; arr[R]) &#123;</span><br><span class="line">swap(arr, index++, ++less);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">swap(arr, index, --more);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">swap(arr, more, R);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] &#123; less + <span class="number">1</span>, more &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">arr[i] = arr[j];</span><br><span class="line">arr[j] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 快排递归版本</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort1</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">process(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> L, <span class="type">int</span> R)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (L &gt;= R) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">swap(arr, L + (<span class="type">int</span>) (Math.random() * (R - L + <span class="number">1</span>)), R);</span><br><span class="line"><span class="type">int</span>[] equalArea = netherlandsFlag(arr, L, R);</span><br><span class="line">process(arr, L, equalArea[<span class="number">0</span>] - <span class="number">1</span>);</span><br><span class="line">process(arr, equalArea[<span class="number">1</span>] + <span class="number">1</span>, R);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 快排非递归版本需要的辅助类</span></span><br><span class="line"><span class="comment">// 要处理的是什么范围上的排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Op</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> l;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> r;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Op</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">l = left;</span><br><span class="line">r = right;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 快排3.0 非递归版本 用栈来执行</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort2</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> arr.length;</span><br><span class="line">swap(arr, (<span class="type">int</span>) (Math.random() * N), N - <span class="number">1</span>);</span><br><span class="line"><span class="type">int</span>[] equalArea = netherlandsFlag(arr, <span class="number">0</span>, N - <span class="number">1</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">el</span> <span class="operator">=</span> equalArea[<span class="number">0</span>];</span><br><span class="line"><span class="type">int</span> <span class="variable">er</span> <span class="operator">=</span> equalArea[<span class="number">1</span>];</span><br><span class="line">Stack&lt;Op&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">stack.push(<span class="keyword">new</span> <span class="title class_">Op</span>(<span class="number">0</span>, el - <span class="number">1</span>));</span><br><span class="line">stack.push(<span class="keyword">new</span> <span class="title class_">Op</span>(er + <span class="number">1</span>, N - <span class="number">1</span>));</span><br><span class="line"><span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line"><span class="type">Op</span> <span class="variable">op</span> <span class="operator">=</span> stack.pop(); <span class="comment">// op.l ... op.r</span></span><br><span class="line"><span class="keyword">if</span> (op.l &lt; op.r) &#123;</span><br><span class="line">swap(arr, op.l + (<span class="type">int</span>) (Math.random() * (op.r - op.l + <span class="number">1</span>)), op.r);</span><br><span class="line">equalArea = netherlandsFlag(arr, op.l, op.r);</span><br><span class="line">el = equalArea[<span class="number">0</span>];</span><br><span class="line">er = equalArea[<span class="number">1</span>];</span><br><span class="line">stack.push(<span class="keyword">new</span> <span class="title class_">Op</span>(op.l, el - <span class="number">1</span>));</span><br><span class="line">stack.push(<span class="keyword">new</span> <span class="title class_">Op</span>(er + <span class="number">1</span>, op.r));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 快排3.0 非递归版本 用队列来执行</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort3</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> arr.length;</span><br><span class="line">swap(arr, (<span class="type">int</span>) (Math.random() * N), N - <span class="number">1</span>);</span><br><span class="line"><span class="type">int</span>[] equalArea = netherlandsFlag(arr, <span class="number">0</span>, N - <span class="number">1</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">el</span> <span class="operator">=</span> equalArea[<span class="number">0</span>];</span><br><span class="line"><span class="type">int</span> <span class="variable">er</span> <span class="operator">=</span> equalArea[<span class="number">1</span>];</span><br><span class="line">Queue&lt;Op&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">queue.offer(<span class="keyword">new</span> <span class="title class_">Op</span>(<span class="number">0</span>, el - <span class="number">1</span>));</span><br><span class="line">queue.offer(<span class="keyword">new</span> <span class="title class_">Op</span>(er + <span class="number">1</span>, N - <span class="number">1</span>));</span><br><span class="line"><span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line"><span class="type">Op</span> <span class="variable">op</span> <span class="operator">=</span> queue.poll();</span><br><span class="line"><span class="keyword">if</span> (op.l &lt; op.r) &#123;</span><br><span class="line">swap(arr, op.l + (<span class="type">int</span>) (Math.random() * (op.r - op.l + <span class="number">1</span>)), op.r);</span><br><span class="line">equalArea = netherlandsFlag(arr, op.l, op.r);</span><br><span class="line">el = equalArea[<span class="number">0</span>];</span><br><span class="line">er = equalArea[<span class="number">1</span>];</span><br><span class="line">queue.offer(<span class="keyword">new</span> <span class="title class_">Op</span>(op.l, el - <span class="number">1</span>));</span><br><span class="line">queue.offer(<span class="keyword">new</span> <span class="title class_">Op</span>(er + <span class="number">1</span>, op.r));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成随机数组（用于测试）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] generateRandomArray(<span class="type">int</span> maxSize, <span class="type">int</span> maxValue) &#123;</span><br><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[(<span class="type">int</span>) ((maxSize + <span class="number">1</span>) * Math.random())];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">arr[i] = (<span class="type">int</span>) ((maxValue + <span class="number">1</span>) * Math.random()) - (<span class="type">int</span>) (maxValue * Math.random());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷贝数组（用于测试）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] copyArray(<span class="type">int</span>[] arr) &#123;</span><br><span class="line"><span class="keyword">if</span> (arr == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">res[i] = arr[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对比两个数组（用于测试）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isEqual</span><span class="params">(<span class="type">int</span>[] arr1, <span class="type">int</span>[] arr2)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> ((arr1 == <span class="literal">null</span> &amp;&amp; arr2 != <span class="literal">null</span>) || (arr1 != <span class="literal">null</span> &amp;&amp; arr2 == <span class="literal">null</span>)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (arr1 == <span class="literal">null</span> &amp;&amp; arr2 == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (arr1.length != arr2.length) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr1.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (arr1[i] != arr2[i]) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印数组（用于测试）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printArray</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (arr == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">System.out.print(arr[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 跑大样本随机测试（对数器）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">testTime</span> <span class="operator">=</span> <span class="number">500000</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">maxSize</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">maxValue</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">succeed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;test begin&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; testTime; i++) &#123;</span><br><span class="line"><span class="type">int</span>[] arr1 = generateRandomArray(maxSize, maxValue);</span><br><span class="line"><span class="type">int</span>[] arr2 = copyArray(arr1);</span><br><span class="line"><span class="type">int</span>[] arr3 = copyArray(arr1);</span><br><span class="line">quickSort1(arr1);</span><br><span class="line">quickSort2(arr2);</span><br><span class="line">quickSort3(arr3);</span><br><span class="line"><span class="keyword">if</span> (!isEqual(arr1, arr2) || !isEqual(arr1, arr3)) &#123;</span><br><span class="line">succeed = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;test end&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;测试&quot;</span> + testTime + <span class="string">&quot;组是否全部通过：&quot;</span> + (succeed ? <span class="string">&quot;是&quot;</span> : <span class="string">&quot;否&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="六、堆排序"><a href="#六、堆排序" class="headerlink" title="六、堆排序"></a>六、堆排序</h3><p>要学习堆排序首先要了解堆结构。</p><p>堆分为大根堆和小根堆。大根堆：要求整棵完全二叉树，每棵子树的顶点的值是这个子树中最大的。小根堆相反。因为堆结构是特殊的完全二叉树。</p><p>那么，怎么构造堆结构呢？</p><p>在构造之前，我们需要知道：一个数组，从0开始到N的一段空间可以构造为完全二叉树。为什么？</p><p>完全二叉树有一下性质（i是当前结点）：父结点：(i-1)&#x2F;2 ; 左孩子：2i+1 ； 右孩子：2i+2。因为数组下标0刚好和完全二叉树顶点对应，所以说可以构造为完全二叉树。</p><p>然后我们开始构造堆结构。</p><p>第一个问题：怎么调整完全二叉树，使它变为一个大根堆？</p><p>用heapsize表示现在数组从0开始有多少空间可以构造为完全二叉树，即大根堆。heapsize初始值为0，因为用户此时还没有给我数，数组为空。</p><p>第一个数N1：将N1放到数组中下标i&#x3D;0位置，也是完全二叉树的头结点。heapsize++</p><p>第二个数N2：放到i&#x3D;1位置，作为N1的左孩子，此时，应用公式(i-1)&#x2F;2求得父结点下标，可以得到对应的数值，即N1，比较大小，如果N2大于N1，那么调换位置，否则，就不变。heapsize++；</p><p>第三个数N3：i&#x3D;3位置，作为N1的右孩子，同样，应用公式，得到父结点下标然后获得相应值，比较大小，如果N3更大，则交换位置，否则不变。heapsize++；</p><p>………</p><p>用这种方法，可以将一个数组调整为大根堆结构，小根堆也是同理。</p><p>下面称此方法为上浮。</p><p>这种方法是O(logN)的，因为高度是logN的。</p><p>第二个问题：用户想得到最大值，并将最大值消去，那么怎么调整才能继续保持大根堆？</p><p>最大值就是i&#x3D;0位置的值，返回就可以。</p><p>那么消去后，怎么保持？</p><p>第一步：将整棵树最后一位数放到顶点。heapsize-1，其实就相当于原来位置的数舍去了，因为我们是用heapsize来规定整个可以划分的范围的。</p><p>第二步：选出左右孩子中大的那个，和这个换过来的数比较，如果孩子更大，那么调换位置，然后继续这个过程，否则不变。</p><p>此方法称为下沉。</p><p>第三个问题：如果用户替换数组中任意位置的数，即替换树中任意位置的数，那么，替换后，怎么保持？</p><p>很简单，最终的结果，要么上浮，要么下沉。只需要走这两部其中一步，就可以保持大根堆。</p><p>了解了上面的知识，下面就可以学习堆排序了。</p><p>第一步：给定一个数组，我们可以认为此时heapsize&#x3D;0，也就是说此时数组此时没有用于堆排序的空间，然后我们可以这样想，要排这个数组，可以认为从0开始往数组中添加，然后heapsize+1，执行上浮过程，这样就将数组构造为一个大根堆；</p><p>第二步：将构建好的大根堆树最后一个结点与顶点交换，然后让heapsize-1，这样就范围就缩小了，原先的顶点换到末尾，并且在之后的步骤中不参与堆排序的过程，这样就确定好一个值了；</p><p>第三步：末尾的结点变成顶点后，要执行下沉过程，将新的树保持为大根堆；</p><p>第四步：重复上述过程，这样，当最后heapsize的值变为0后，就代表堆排序过程结束，数组有序。</p><p>上面就是堆排序过程。</p><p>时间复杂度为O(N * logN)，分为上浮和下沉两个过程。</p><p>补充：上面将数组构造为大根堆的过程，也就是上浮过程，其实还有另一种思路。上浮过程是假设数组为空，heapsize起始为0，然后从顶点开始，一个一个向下添加，不断向下，添加一个，调整一个。</p><p>另一个思路是：不一个一个添加，直接就将数组中所有的数据构造为完全二叉树，之后，从最后一个结点开始，逐渐向前调整，执行下沉过程，将每一个结点都调整为大根堆，这样，当到上一级树时，只需要调整它和它孩子就可以了，这样，最后也可以构成一个大根堆。</p><p>第二个思路比第一个思路快一点，但是，只是构造大根堆的速度快一点，之后还是要进行排序过程，整体的时间复杂度还是O(N * logN)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> class06;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Code03_HeapSort</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 堆排序额外空间复杂度O(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">heapSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// O(N*logN)</span></span><br><span class="line"><span class="comment">//for (int i = 0; i &lt; arr.length; i++) &#123; // O(N)</span></span><br><span class="line"><span class="comment">//heapInsert(arr, i); // O(logN)</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">// O(N)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> arr.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">heapify(arr, i, arr.length);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">heapSize</span> <span class="operator">=</span> arr.length;</span><br><span class="line">swap(arr, <span class="number">0</span>, --heapSize);</span><br><span class="line"><span class="comment">// O(N*logN)</span></span><br><span class="line"><span class="keyword">while</span> (heapSize &gt; <span class="number">0</span>) &#123; <span class="comment">// O(N)</span></span><br><span class="line">heapify(arr, <span class="number">0</span>, heapSize); <span class="comment">// O(logN)</span></span><br><span class="line">swap(arr, <span class="number">0</span>, --heapSize); <span class="comment">// O(1)</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// arr[index]刚来的数，往上</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">heapInsert</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> index)</span> &#123;</span><br><span class="line"><span class="keyword">while</span> (arr[index] &gt; arr[(index - <span class="number">1</span>) / <span class="number">2</span>]) &#123;</span><br><span class="line">swap(arr, index, (index - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">index = (index - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// arr[index]位置的数，能否往下移动</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">heapify</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> index, <span class="type">int</span> heapSize)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> index * <span class="number">2</span> + <span class="number">1</span>; <span class="comment">// 左孩子的下标</span></span><br><span class="line"><span class="keyword">while</span> (left &lt; heapSize) &#123; <span class="comment">// 下方还有孩子的时候</span></span><br><span class="line"><span class="comment">// 两个孩子中，谁的值大，把下标给largest</span></span><br><span class="line"><span class="comment">// 1）只有左孩子，left -&gt; largest</span></span><br><span class="line"><span class="comment">// 2) 同时有左孩子和右孩子，右孩子的值&lt;= 左孩子的值，left -&gt; largest</span></span><br><span class="line"><span class="comment">// 3) 同时有左孩子和右孩子并且右孩子的值&gt; 左孩子的值， right -&gt; largest</span></span><br><span class="line"><span class="type">int</span> <span class="variable">largest</span> <span class="operator">=</span> left + <span class="number">1</span> &lt; heapSize &amp;&amp; arr[left + <span class="number">1</span>] &gt; arr[left] ? left + <span class="number">1</span> : left;</span><br><span class="line"><span class="comment">// 父和较大的孩子之间，谁的值大，把下标给largest</span></span><br><span class="line">largest = arr[largest] &gt; arr[index] ? largest : index;</span><br><span class="line"><span class="keyword">if</span> (largest == index) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">swap(arr, largest, index);</span><br><span class="line">index = largest;</span><br><span class="line">left = index * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">arr[i] = arr[j];</span><br><span class="line">arr[j] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认小根堆，这是Java自带的，自己维护的小根堆</span></span><br><span class="line">PriorityQueue&lt;Integer&gt; heap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line">heap.add(<span class="number">6</span>);</span><br><span class="line">heap.add(<span class="number">8</span>);</span><br><span class="line">heap.add(<span class="number">0</span>);</span><br><span class="line">heap.add(<span class="number">2</span>);</span><br><span class="line">heap.add(<span class="number">9</span>);</span><br><span class="line">heap.add(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!heap.isEmpty()) &#123;</span><br><span class="line">System.out.println(heap.poll());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">testTime</span> <span class="operator">=</span> <span class="number">500000</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">maxSize</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">maxValue</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">succeed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; testTime; i++) &#123;</span><br><span class="line"><span class="type">int</span>[] arr1 = generateRandomArray(maxSize, maxValue);</span><br><span class="line"><span class="type">int</span>[] arr2 = copyArray(arr1);</span><br><span class="line">heapSort(arr1);</span><br><span class="line">comparator(arr2);</span><br><span class="line"><span class="keyword">if</span> (!isEqual(arr1, arr2)) &#123;</span><br><span class="line">succeed = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(succeed ? <span class="string">&quot;Nice!&quot;</span> : <span class="string">&quot;Fucking fucked!&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>[] arr = generateRandomArray(maxSize, maxValue);</span><br><span class="line">printArray(arr);</span><br><span class="line">heapSort(arr);</span><br><span class="line">printArray(arr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="七、基数排序-桶排序"><a href="#七、基数排序-桶排序" class="headerlink" title="七、基数排序(桶排序)"></a>七、基数排序(桶排序)</h3><p>说基数排序之前，我们需要知道排序有比较排序和非比较排序。</p><p>比较排序就是类似于上面讲的那些普通排序，通过比较的方式得出结果。</p><p>而非比较排序，就是说采用特定的方法，不进行类似于上面排序那样的比较，但得到相同结果的一种排序方法。举个例子：一个数组，里面储存了一些人年龄的数据，大小是0-200，我们定义一个新数组，大小是200+1，或者200。我们先把一岁的数据找出来，并存入新数组；然后找出二岁的所有数据，……这样，新数组就是从一开始的有序数组。【11112222333】</p><p>上面的方法也叫计数排序。</p><p>但是这样的缺点很明显，试想我现在原数组的范围是2^-123455  -   2^123455,这样的范围，那我的新数组要准备多大的，所以说不现实。</p><p>非比较排序相较于原先的比较排序，一个很明显的特点就是它受限于数据特征，它更像是为一些特定数据根据数据相关特点量身打造的排序。就是说它的适用性不高。</p><p>基数排序，也叫桶排序，就是非比较排序里面比较典型的一种排序。</p><p>先说思路：先准备十个桶，从0到9，再看数组中最大的数值是多少位的，然后将其它数字前面加上0。</p><p>将数组中的值从左往右遍历。先看个位，按照数字放入相应的桶中，先进入桶的在上面，后入的依次放到后面。这样放完之后，再将桶中的数字倒出来，从0号桶开始倒，这就是第一步根据个位的排序了；然后也是一样的，排十位…….</p><p>下面贴代码，代码进行了相关优化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> class08;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Code04_RadixSort</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// only for no-negative value</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">radixSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">radixSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>, maxbits(arr));</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//求数组中最大的值的位数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxbits</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="comment">//先让max为整形最大</span></span><br><span class="line"><span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">        <span class="comment">//求最大值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">max = Math.max(max, arr[i]);</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">//下面就是求最大值有多少位，每次除0</span></span><br><span class="line"><span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (max != <span class="number">0</span>) &#123;</span><br><span class="line">res++;</span><br><span class="line">max /= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// arr[L..R]排序  ,  最大值的十进制位数digit</span></span><br><span class="line">    <span class="comment">//radixSort是想让arr在L-R上面进行排序，不一定是从0到末尾</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">radixSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> digit)</span> &#123;</span><br><span class="line">        <span class="comment">//radix就是桶的数量，总是10个，所以是final</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="variable">radix</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 有多少个数准备多少个辅助空间</span></span><br><span class="line"><span class="type">int</span>[] help = <span class="keyword">new</span> <span class="title class_">int</span>[R - L + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">1</span>; d &lt;= digit; d++) &#123; <span class="comment">// 有多少位就进出几次</span></span><br><span class="line"><span class="comment">// 10个空间</span></span><br><span class="line">    <span class="comment">// count[0] 当前位(d位)是0的数字有多少个</span></span><br><span class="line"><span class="comment">// count[1] 当前位(d位)是(0和1)的数字有多少个</span></span><br><span class="line"><span class="comment">// count[2] 当前位(d位)是(0、1和2)的数字有多少个</span></span><br><span class="line"><span class="comment">// count[i] 当前位(d位)是(0~i)的数字有多少个</span></span><br><span class="line"><span class="type">int</span>[] count = <span class="keyword">new</span> <span class="title class_">int</span>[radix]; <span class="comment">// count[0..9]</span></span><br><span class="line">            <span class="comment">//从左往右遍历数组，先看个位，看第几位是由d来控制的</span></span><br><span class="line"><span class="keyword">for</span> (i = L; i &lt;= R; i++) &#123;</span><br><span class="line"><span class="comment">// 103  1   3</span></span><br><span class="line"><span class="comment">// 209  1   9</span></span><br><span class="line">                <span class="comment">//得到个位的数值</span></span><br><span class="line">j = getDigit(arr[i], d);</span><br><span class="line">                <span class="comment">//然后让相应桶的数值++，相当于进桶</span></span><br><span class="line">count[j]++;</span><br><span class="line">&#125;</span><br><span class="line">            <span class="comment">//将桶中，也就是数组中，记录的数据从左往右，累加过去，也就是每一位上的数值都是前面累加的和</span></span><br><span class="line">            <span class="comment">//原先没有加的时候，count中每一个位置的数据代表：这一个数字有多少个数据</span></span><br><span class="line">            <span class="comment">//for之后，也就是加完之后，每一个位置代表：小于等于当前下标(i)，也就是数字的数据有多少个</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; radix; i++) &#123;</span><br><span class="line">count[i] = count[i] + count[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">            <span class="comment">//原数组从右往左看，从个位开始，由d来控制当前要看的位</span></span><br><span class="line"><span class="keyword">for</span> (i = R; i &gt;= L; i--) &#123;</span><br><span class="line">                <span class="comment">//得到数据当前位的数字</span></span><br><span class="line">j = getDigit(arr[i], d);</span><br><span class="line">                <span class="comment">//根据count的特点，将这个数据放到count记录的数值-1的下标当中去</span></span><br><span class="line">help[count[j] - <span class="number">1</span>] = arr[i];</span><br><span class="line">                <span class="comment">//然后让相应数字对应的值-1，就是说已经排好一个数了</span></span><br><span class="line">count[j]--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = L, j = <span class="number">0</span>; i &lt;= R; i++, j++) &#123;</span><br><span class="line">arr[i] = help[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getDigit</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> d)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> ((x / ((<span class="type">int</span>) Math.pow(<span class="number">10</span>, d - <span class="number">1</span>))) % <span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">testTime</span> <span class="operator">=</span> <span class="number">500000</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">maxSize</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">maxValue</span> <span class="operator">=</span> <span class="number">100000</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">succeed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; testTime; i++) &#123;</span><br><span class="line"><span class="type">int</span>[] arr1 = generateRandomArray(maxSize, maxValue);</span><br><span class="line"><span class="type">int</span>[] arr2 = copyArray(arr1);</span><br><span class="line">radixSort(arr1);</span><br><span class="line">comparator(arr2);</span><br><span class="line"><span class="keyword">if</span> (!isEqual(arr1, arr2)) &#123;</span><br><span class="line">succeed = <span class="literal">false</span>;</span><br><span class="line">printArray(arr1);</span><br><span class="line">printArray(arr2);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(succeed ? <span class="string">&quot;Nice!&quot;</span> : <span class="string">&quot;Fucking fucked!&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>[] arr = generateRandomArray(maxSize, maxValue);</span><br><span class="line">printArray(arr);</span><br><span class="line">radixSort(arr);</span><br><span class="line">printArray(arr);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码的关键在于count数组，count数组从左到右累加之后，可以确定的是：</p><p>1、下标就相当于桶，0-9</p><p>2、下标对应的数据，意思是：小于当前下标的数据有几个，也就是说小于当前数字的数据有几个，因为它累加了；</p><p>3、要明确下标确定的几个数据，也就是桶中的几个数据，倒出来的时候，在新数组中是一片连续的区域，是【111222333】这样的。</p><p>4、我从右往左遍历，相当于反过来了，就是说我先处理最后放进桶的数据，比如个位是2，我又通过count知道比2小的数据有5个，那这个个位为2的数据必然放在新数组中下标为4的位置，为什么？注意第三点!新数组中，也就是出桶后，数据是根据位数字排好的！连续的，我现在知道比2小的数据有5个，那这5个就包含11122这样，你又是最后进桶的，也要是最后出桶，当然在最后面。</p><h3 id="八、希尔排序"><a href="#八、希尔排序" class="headerlink" title="八、希尔排序"></a>八、希尔排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> class08;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是希尔排序，课上没有讲，因为比较简单，有兴趣的同学可以看一下</span></span><br><span class="line"><span class="comment">// 今天在面试场上也基本不怎么问了</span></span><br><span class="line"><span class="comment">// 这个排序就是调整步长的插入排序，也可以认为是插入排序的小改进版本</span></span><br><span class="line"><span class="comment">// 改变不了时间复杂度，只是优化了常数时间</span></span><br><span class="line"><span class="comment">// 我还写了和插入排序的性能对比</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Code05_ShellSort</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">shellSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 步长依次为5、2、1</span></span><br><span class="line"><span class="comment">// 在插入排序中，一步一步往前交换，直到左边的数&lt;=当前的数，停止</span></span><br><span class="line"><span class="comment">// 在希尔排序中，如果步长依次为5、2、1</span></span><br><span class="line"><span class="comment">// 那么来到每个数，每次跳5步往前交换，直到往前5步的数&lt;=当前的数，停止</span></span><br><span class="line"><span class="comment">// 然后再来到每个数，每次跳3步往前交换，直到往前3步的数&lt;=当前的数，停止</span></span><br><span class="line"><span class="comment">// 然后再来到每个数，每次跳1步往前交换，直到往前1步的数&lt;=当前的数，停止</span></span><br><span class="line"><span class="type">int</span>[] step = &#123; <span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> <span class="number">0</span>; s &lt; step.length; s++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i - step[s]; j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; arr[j + step[s]]; j -= step[s]) &#123;</span><br><span class="line">swap(arr, j, j + step[s]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">arr[i] = arr[j];</span><br><span class="line">arr[j] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 为了测试</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">testTime</span> <span class="operator">=</span> <span class="number">500000</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">maxSize</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">maxValue</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">succeed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; testTime; i++) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> (<span class="type">int</span>) (Math.random() * maxSize);</span><br><span class="line"><span class="type">int</span>[] arr1 = generateRandomArray(len, maxValue);</span><br><span class="line"><span class="type">int</span>[] arr2 = copyArray(arr1);</span><br><span class="line">shellSort(arr1);</span><br><span class="line">insertionSort(arr2);</span><br><span class="line"><span class="keyword">if</span> (!isEqual(arr1, arr2)) &#123;</span><br><span class="line">succeed = <span class="literal">false</span>;</span><br><span class="line">printArray(arr1);</span><br><span class="line">printArray(arr2);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(succeed ? <span class="string">&quot;功能测试通过！&quot;</span> : <span class="string">&quot;功能测试不通过！&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">100000</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;数据样本长度 : &quot;</span> + len);</span><br><span class="line"><span class="type">int</span>[] arr1 = generateRandomArray(len, maxValue);</span><br><span class="line"><span class="type">int</span>[] arr2 = copyArray(arr1);</span><br><span class="line"><span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">start = System.currentTimeMillis();</span><br><span class="line">shellSort(arr1);</span><br><span class="line">end = System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">&quot;希尔排序运行时间 : &quot;</span> + (end - start) + <span class="string">&quot; 毫秒&quot;</span>);</span><br><span class="line">start = System.currentTimeMillis();</span><br><span class="line">insertionSort(arr2);</span><br><span class="line">end = System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">&quot;插入排序运行时间 : &quot;</span> + (end - start) + <span class="string">&quot; 毫秒&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、链表"><a href="#2、链表" class="headerlink" title="2、链表"></a>2、链表</h2><h3 id="判断是否是回文链表"><a href="#判断是否是回文链表" class="headerlink" title="判断是否是回文链表"></a>判断是否是回文链表</h3><p>首先要知道的是：什么是回文呢？</p><p>回文是指：从左边遍历和从右边遍历两边值相等。比如12321这样的。需要注意的是，链表结构最小元素是结点node，比如：</p><p>1-20-3-20-1，这样的，这也是回文，本来说回文应该是1203021，但是因为是一个结点，一个整体，所以也是符合的。</p><p>有三种方法实现。</p><p>1、是借助一个栈，根据栈先入后出的特性，全部数据入完栈后，再一个一个出栈，出栈的同时也要遍历链表，出一个，判断一个是否相等，直到栈为空，若都相等，则为回文。</p><p>2、方法1可以优化，可以只进一半的数进栈就可以，设置快慢指针，一个指针每次走两步，一个每次走一步，保证当快指针走到末尾时，慢指针走到链表中间，然后然慢指针逐渐往后，同时所指的元素依次进栈，直到慢指针走到末尾。之后head指针从头开始，遍历，栈元素也一个一个出栈，依次比较，若相等，则为回文。</p><p>3、方法3不需要用到额外空间。同样使用快慢指针，让慢指针指向链表中间，然后让慢指针此时所指的元素下一个指向空，同时改变中间元素后面结点的指向，让后面结点方向调转，然后再拿两个指针，分别从开头和末尾开始遍历，此时，若都相等，则是回文链表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> class09;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Code02_IsPalindromeList</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> value;</span><br><span class="line"><span class="keyword">public</span> Node next;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.value = data;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// need n extra space</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isPalindrome1</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">Stack&lt;Node&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;Node&gt;();</span><br><span class="line"><span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line"><span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">stack.push(cur);</span><br><span class="line">cur = cur.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (head != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (head.value != stack.pop().value) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">head = head.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// need n/2 extra space</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isPalindrome2</span><span class="params">(Node head)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">Node</span> <span class="variable">right</span> <span class="operator">=</span> head.next;</span><br><span class="line"><span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line"><span class="keyword">while</span> (cur.next != <span class="literal">null</span> &amp;&amp; cur.next.next != <span class="literal">null</span>) &#123;</span><br><span class="line">right = right.next;</span><br><span class="line">cur = cur.next.next;</span><br><span class="line">&#125;</span><br><span class="line">Stack&lt;Node&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;Node&gt;();</span><br><span class="line"><span class="keyword">while</span> (right != <span class="literal">null</span>) &#123;</span><br><span class="line">stack.push(right);</span><br><span class="line">right = right.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">if</span> (head.value != stack.pop().value) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">head = head.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// need O(1) extra space</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isPalindrome3</span><span class="params">(Node head)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">Node</span> <span class="variable">n1</span> <span class="operator">=</span> head;</span><br><span class="line"><span class="type">Node</span> <span class="variable">n2</span> <span class="operator">=</span> head;</span><br><span class="line"><span class="keyword">while</span> (n2.next != <span class="literal">null</span> &amp;&amp; n2.next.next != <span class="literal">null</span>) &#123; <span class="comment">// find mid node</span></span><br><span class="line">n1 = n1.next; <span class="comment">// n1 -&gt; mid</span></span><br><span class="line">n2 = n2.next.next; <span class="comment">// n2 -&gt; end</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// n1 中点</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">n2 = n1.next; <span class="comment">// n2 -&gt; right part first node</span></span><br><span class="line">n1.next = <span class="literal">null</span>; <span class="comment">// mid.next -&gt; null</span></span><br><span class="line"><span class="type">Node</span> <span class="variable">n3</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">while</span> (n2 != <span class="literal">null</span>) &#123; <span class="comment">// right part convert</span></span><br><span class="line">n3 = n2.next; <span class="comment">// n3 -&gt; save next node</span></span><br><span class="line">n2.next = n1; <span class="comment">// next of right node convert</span></span><br><span class="line">n1 = n2; <span class="comment">// n1 move</span></span><br><span class="line">n2 = n3; <span class="comment">// n2 move</span></span><br><span class="line">&#125;</span><br><span class="line">n3 = n1; <span class="comment">// n3 -&gt; save last node</span></span><br><span class="line">n2 = head;<span class="comment">// n2 -&gt; left first node</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">res</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span> (n1 != <span class="literal">null</span> &amp;&amp; n2 != <span class="literal">null</span>) &#123; <span class="comment">// check palindrome</span></span><br><span class="line"><span class="keyword">if</span> (n1.value != n2.value) &#123;</span><br><span class="line">res = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">n1 = n1.next; <span class="comment">// left to mid</span></span><br><span class="line">n2 = n2.next; <span class="comment">// right to mid</span></span><br><span class="line">&#125;</span><br><span class="line">n1 = n3.next;</span><br><span class="line">n3.next = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">while</span> (n1 != <span class="literal">null</span>) &#123; <span class="comment">// recover list</span></span><br><span class="line">n2 = n1.next;</span><br><span class="line">n1.next = n3;</span><br><span class="line">n3 = n1;</span><br><span class="line">n1 = n2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printLinkedList</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">System.out.print(<span class="string">&quot;Linked List: &quot;</span>);</span><br><span class="line"><span class="keyword">while</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">System.out.print(node.value + <span class="string">&quot; &quot;</span>);</span><br><span class="line">node = node.next;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>需要注意的是：快慢指针是一种手段，当快指针走到末尾时，慢指针具体定位到哪里，可以自己设置，但是，这需要自己coding，不断总结得出结论。</strong></p><p>写此类链表题目常用的手段：</p><p>一是额外空间；二就是快慢指针。</p><h3 id="三分链表"><a href="#三分链表" class="headerlink" title="三分链表"></a>三分链表</h3><p>将单向链表按某值划分成左边小、中间相等、右边大的形式。</p><p>1、笔试上可以这么做：新建一个Node类型的数组，将链表元素添加进数组中，然后对数组进行快速排序过程，最后连接，这样就划分好了。</p><p>2、另外一种方法：命名6个变量，分别是小于部分的头尾指针、等于的头尾指针、大于的头尾指针。遍历链表，依次判断每个元素，比如：第一个元素小于，那么就让小于的头尾指针都指向这个元素，如果又有元素小于，就改变尾指针的指向，让尾指针指向新的小于元素，同理，等于和大于也是这样，到最后，让小于的尾连接等于的头，等于的尾连接大于的头，这样就连接了。</p><p>注意！方法2要注意边界，就是如果没有等于部分怎么办？没有大于部分怎么办？或者二者都没有怎么办？这些要进行边界判断。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> class09;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Code03_SmallerEqualBigger</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> value;</span><br><span class="line"><span class="keyword">public</span> Node next;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.value = data;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title function_">listPartition1</span><span class="params">(Node head, <span class="type">int</span> pivot)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">i++;</span><br><span class="line">cur = cur.next;</span><br><span class="line">&#125;</span><br><span class="line">Node[] nodeArr = <span class="keyword">new</span> <span class="title class_">Node</span>[i];</span><br><span class="line">i = <span class="number">0</span>;</span><br><span class="line">cur = head;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i != nodeArr.length; i++) &#123;</span><br><span class="line">nodeArr[i] = cur;</span><br><span class="line">cur = cur.next;</span><br><span class="line">&#125;</span><br><span class="line">arrPartition(nodeArr, pivot);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i != nodeArr.length; i++) &#123;</span><br><span class="line">nodeArr[i - <span class="number">1</span>].next = nodeArr[i];</span><br><span class="line">&#125;</span><br><span class="line">nodeArr[i - <span class="number">1</span>].next = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">return</span> nodeArr[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">arrPartition</span><span class="params">(Node[] nodeArr, <span class="type">int</span> pivot)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">small</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">big</span> <span class="operator">=</span> nodeArr.length;</span><br><span class="line"><span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (index != big) &#123;</span><br><span class="line"><span class="keyword">if</span> (nodeArr[index].value &lt; pivot) &#123;</span><br><span class="line">swap(nodeArr, ++small, index++);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (nodeArr[index].value == pivot) &#123;</span><br><span class="line">index++;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">swap(nodeArr, --big, index);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(Node[] nodeArr, <span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line"><span class="type">Node</span> <span class="variable">tmp</span> <span class="operator">=</span> nodeArr[a];</span><br><span class="line">nodeArr[a] = nodeArr[b];</span><br><span class="line">nodeArr[b] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title function_">listPartition2</span><span class="params">(Node head, <span class="type">int</span> pivot)</span> &#123;</span><br><span class="line"><span class="type">Node</span> <span class="variable">sH</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// small head</span></span><br><span class="line"><span class="type">Node</span> <span class="variable">sT</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// small tail</span></span><br><span class="line"><span class="type">Node</span> <span class="variable">eH</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// equal head</span></span><br><span class="line"><span class="type">Node</span> <span class="variable">eT</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// equal tail</span></span><br><span class="line"><span class="type">Node</span> <span class="variable">mH</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// big head</span></span><br><span class="line"><span class="type">Node</span> <span class="variable">mT</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// big tail</span></span><br><span class="line"><span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// save next node</span></span><br><span class="line"><span class="comment">// every node distributed to three lists</span></span><br><span class="line"><span class="keyword">while</span> (head != <span class="literal">null</span>) &#123;</span><br><span class="line">next = head.next;</span><br><span class="line">head.next = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> (head.value &lt; pivot) &#123;</span><br><span class="line"><span class="keyword">if</span> (sH == <span class="literal">null</span>) &#123;</span><br><span class="line">sH = head;</span><br><span class="line">sT = head;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">sT.next = head;</span><br><span class="line">sT = head;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (head.value == pivot) &#123;</span><br><span class="line"><span class="keyword">if</span> (eH == <span class="literal">null</span>) &#123;</span><br><span class="line">eH = head;</span><br><span class="line">eT = head;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">eT.next = head;</span><br><span class="line">eT = head;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (mH == <span class="literal">null</span>) &#123;</span><br><span class="line">mH = head;</span><br><span class="line">mT = head;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">mT.next = head;</span><br><span class="line">mT = head;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">head = next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 小于区域的尾巴，连等于区域的头，等于区域的尾巴连大于区域的头</span></span><br><span class="line"><span class="keyword">if</span> (sT != <span class="literal">null</span>) &#123; <span class="comment">// 如果有小于区域</span></span><br><span class="line">sT.next = eH;</span><br><span class="line">eT = eT == <span class="literal">null</span> ? sT : eT; <span class="comment">// 下一步，谁去连大于区域的头，谁就变成eT</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 下一步，一定是需要用eT 去接 大于区域的头</span></span><br><span class="line"><span class="comment">// 有等于区域，eT -&gt; 等于区域的尾结点</span></span><br><span class="line"><span class="comment">// 无等于区域，eT -&gt; 小于区域的尾结点</span></span><br><span class="line"><span class="comment">// eT 尽量不为空的尾巴节点</span></span><br><span class="line"><span class="keyword">if</span> (eT != <span class="literal">null</span>) &#123; <span class="comment">// 如果小于区域和等于区域，不是都没有</span></span><br><span class="line">eT.next = mH;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sH != <span class="literal">null</span> ? sH : (eH != <span class="literal">null</span> ? eH : mH);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printLinkedList</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">System.out.print(<span class="string">&quot;Linked List: &quot;</span>);</span><br><span class="line"><span class="keyword">while</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">System.out.print(node.value + <span class="string">&quot; &quot;</span>);</span><br><span class="line">node = node.next;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">Node</span> <span class="variable">head1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">7</span>);</span><br><span class="line">head1.next = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">9</span>);</span><br><span class="line">head1.next.next = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">1</span>);</span><br><span class="line">head1.next.next.next = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">8</span>);</span><br><span class="line">head1.next.next.next.next = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">5</span>);</span><br><span class="line">head1.next.next.next.next.next = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">2</span>);</span><br><span class="line">head1.next.next.next.next.next.next = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">5</span>);</span><br><span class="line">printLinkedList(head1);</span><br><span class="line"><span class="comment">// head1 = listPartition1(head1, 4);</span></span><br><span class="line">head1 = listPartition2(head1, <span class="number">5</span>);</span><br><span class="line">printLinkedList(head1);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题目三"><a href="#题目三" class="headerlink" title="题目三"></a>题目三</h3><p><img src="C:\Users\jyj123\AppData\Roaming\Typora\typora-user-images\image-20230219234043379.png" alt="image-20230219234043379"></p><p>就是说和普通链表相比，每个结点多了个指针，这个指针是任意的指向，现在就是想复制一个新链表出来，这个新链表和原链表完全一样。</p><p>1、利用哈希数组，key是原结点，value是克隆的原结点，这样依次往原链表添加。遍历原链表，得到每一个结点随意的指针指向，看指向哪一个结点A，同时根据哈希数组得到当前结点的克隆结点，再根据A得到B，所有克隆结点是指向B的。就这样依次进行，可以将所有的克隆结点串起来，最后返回克隆的头结点。</p><p>2、方法2不利用哈希数组，同样依次克隆结点，但是每克隆一个就让这个克隆后的结点接到原结点的后面，直到完成。原链表每一个结点的随意指针的指向还是不变的，我们通过一定的设置，将结点一对一对的拿出来，这样其实就实现了哈希数组的对应关系，然后就是和在哈希数组的操作类似了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> class09;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.com/problems/copy-list-with-random-pointer/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Code04_CopyListWithRandom</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"><span class="type">int</span> val;</span><br><span class="line">Node next;</span><br><span class="line">Node random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.val = val;</span><br><span class="line"><span class="built_in">this</span>.next = <span class="literal">null</span>;</span><br><span class="line"><span class="built_in">this</span>.random = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title function_">copyRandomList1</span><span class="params">(Node head)</span> &#123;</span><br><span class="line"><span class="comment">// key 老节点</span></span><br><span class="line"><span class="comment">// value 新节点</span></span><br><span class="line">HashMap&lt;Node, Node&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Node, Node&gt;();</span><br><span class="line"><span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line"><span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">map.put(cur, <span class="keyword">new</span> <span class="title class_">Node</span>(cur.val));</span><br><span class="line">cur = cur.next;</span><br><span class="line">&#125;</span><br><span class="line">cur = head;</span><br><span class="line"><span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">// cur 老</span></span><br><span class="line"><span class="comment">// map.get(cur) 新</span></span><br><span class="line"><span class="comment">// 新.next -&gt;  cur.next克隆节点找到</span></span><br><span class="line">map.get(cur).next = map.get(cur.next);</span><br><span class="line">map.get(cur).random = map.get(cur.random);</span><br><span class="line">cur = cur.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> map.get(head);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title function_">copyRandomList2</span><span class="params">(Node head)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line"><span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// 1 -&gt; 2 -&gt; 3 -&gt; null</span></span><br><span class="line"><span class="comment">// 1 -&gt; 1&#x27; -&gt; 2 -&gt; 2&#x27; -&gt; 3 -&gt; 3&#x27;</span></span><br><span class="line"><span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">next = cur.next;</span><br><span class="line">cur.next = <span class="keyword">new</span> <span class="title class_">Node</span>(cur.val);</span><br><span class="line">cur.next.next = next;</span><br><span class="line">cur = next;</span><br><span class="line">&#125;</span><br><span class="line">cur = head;</span><br><span class="line"><span class="type">Node</span> <span class="variable">copy</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// 1 1&#x27; 2 2&#x27; 3 3&#x27;</span></span><br><span class="line"><span class="comment">// 依次设置 1&#x27; 2&#x27; 3&#x27; random指针</span></span><br><span class="line"><span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">next = cur.next.next;</span><br><span class="line">copy = cur.next;</span><br><span class="line">copy.random = cur.random != <span class="literal">null</span> ? cur.random.next : <span class="literal">null</span>;</span><br><span class="line">cur = next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">Node</span> <span class="variable">res</span> <span class="operator">=</span> head.next;</span><br><span class="line">cur = head;</span><br><span class="line"><span class="comment">// 老 新 混在一起，next方向上，random正确</span></span><br><span class="line"><span class="comment">// next方向上，把新老链表分离</span></span><br><span class="line"><span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">next = cur.next.next;</span><br><span class="line">copy = cur.next;</span><br><span class="line">cur.next = next;</span><br><span class="line">copy.next = next != <span class="literal">null</span> ? next.next : <span class="literal">null</span>;</span><br><span class="line">cur = next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、单链表有环的一些结论"><a href="#3、单链表有环的一些结论" class="headerlink" title="3、单链表有环的一些结论"></a>3、单链表有环的一些结论</h2><p>这个问题就是说：现在存在一个链表，有环，需要我找到链表第一个入环的结点。</p><p>那么，怎么找呢？</p><p>用快慢指针。</p><p><strong>快指针一次走两步，慢指针一次走一步，因为链表有环，所以快指针和慢指针最后一定会相遇，当两个指针相遇时，让快指针回到起点，慢指针不动；接下来，让快指针和慢指针都一次走一步，它们必定会在入环第一个结点相遇。</strong></p><p>上面是一个关于单链表入环结点的一个结论，可以直接记下来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> class10;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Code01_FindFirstIntersectNode</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> value;</span><br><span class="line"><span class="keyword">public</span> Node next;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.value = data;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title function_">getIntersectNode</span><span class="params">(Node head1, Node head2)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (head1 == <span class="literal">null</span> || head2 == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">Node</span> <span class="variable">loop1</span> <span class="operator">=</span> getLoopNode(head1);</span><br><span class="line"><span class="type">Node</span> <span class="variable">loop2</span> <span class="operator">=</span> getLoopNode(head2);</span><br><span class="line"><span class="keyword">if</span> (loop1 == <span class="literal">null</span> &amp;&amp; loop2 == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> noLoop(head1, head2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (loop1 != <span class="literal">null</span> &amp;&amp; loop2 != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> bothLoop(head1, loop1, head2, loop2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到链表第一个入环节点，如果无环，返回null</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title function_">getLoopNode</span><span class="params">(Node head)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span> || head.next.next == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// n1 慢  n2 快</span></span><br><span class="line"><span class="type">Node</span> <span class="variable">slow</span> <span class="operator">=</span> head.next; <span class="comment">// n1 -&gt; slow</span></span><br><span class="line"><span class="type">Node</span> <span class="variable">fast</span> <span class="operator">=</span> head.next.next; <span class="comment">// n2 -&gt; fast</span></span><br><span class="line"><span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line"><span class="keyword">if</span> (fast.next == <span class="literal">null</span> || fast.next.next == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">fast = fast.next.next;</span><br><span class="line">slow = slow.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// slow fast  相遇</span></span><br><span class="line">fast = head; <span class="comment">// n2 -&gt; walk again from head</span></span><br><span class="line"><span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">slow = slow.next;</span><br><span class="line">fast = fast.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果两个链表都无环，返回第一个相交节点，如果不想交，返回null</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title function_">noLoop</span><span class="params">(Node head1, Node head2)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (head1 == <span class="literal">null</span> || head2 == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">Node</span> <span class="variable">cur1</span> <span class="operator">=</span> head1;</span><br><span class="line"><span class="type">Node</span> <span class="variable">cur2</span> <span class="operator">=</span> head2;</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (cur1.next != <span class="literal">null</span>) &#123;</span><br><span class="line">n++;</span><br><span class="line">cur1 = cur1.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (cur2.next != <span class="literal">null</span>) &#123;</span><br><span class="line">n--;</span><br><span class="line">cur2 = cur2.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (cur1 != cur2) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// n  :  链表1长度减去链表2长度的值</span></span><br><span class="line">cur1 = n &gt; <span class="number">0</span> ? head1 : head2; <span class="comment">// 谁长，谁的头变成cur1</span></span><br><span class="line">cur2 = cur1 == head1 ? head2 : head1; <span class="comment">// 谁短，谁的头变成cur2</span></span><br><span class="line">n = Math.abs(n);</span><br><span class="line"><span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">n--;</span><br><span class="line">cur1 = cur1.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (cur1 != cur2) &#123;</span><br><span class="line">cur1 = cur1.next;</span><br><span class="line">cur2 = cur2.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cur1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 两个有环链表，返回第一个相交节点，如果不想交返回null</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title function_">bothLoop</span><span class="params">(Node head1, Node loop1, Node head2, Node loop2)</span> &#123;</span><br><span class="line"><span class="type">Node</span> <span class="variable">cur1</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">Node</span> <span class="variable">cur2</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> (loop1 == loop2) &#123;</span><br><span class="line">cur1 = head1;</span><br><span class="line">cur2 = head2;</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (cur1 != loop1) &#123;</span><br><span class="line">n++;</span><br><span class="line">cur1 = cur1.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (cur2 != loop2) &#123;</span><br><span class="line">n--;</span><br><span class="line">cur2 = cur2.next;</span><br><span class="line">&#125;</span><br><span class="line">cur1 = n &gt; <span class="number">0</span> ? head1 : head2;</span><br><span class="line">cur2 = cur1 == head1 ? head2 : head1;</span><br><span class="line">n = Math.abs(n);</span><br><span class="line"><span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">n--;</span><br><span class="line">cur1 = cur1.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (cur1 != cur2) &#123;</span><br><span class="line">cur1 = cur1.next;</span><br><span class="line">cur2 = cur2.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cur1;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">cur1 = loop1.next;</span><br><span class="line"><span class="keyword">while</span> (cur1 != loop1) &#123;</span><br><span class="line"><span class="keyword">if</span> (cur1 == loop2) &#123;</span><br><span class="line"><span class="keyword">return</span> loop1;</span><br><span class="line">&#125;</span><br><span class="line">cur1 = cur1.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">// 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7-&gt;null</span></span><br><span class="line"><span class="type">Node</span> <span class="variable">head1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">1</span>);</span><br><span class="line">head1.next = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">2</span>);</span><br><span class="line">head1.next.next = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">3</span>);</span><br><span class="line">head1.next.next.next = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">4</span>);</span><br><span class="line">head1.next.next.next.next = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">5</span>);</span><br><span class="line">head1.next.next.next.next.next = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">6</span>);</span><br><span class="line">head1.next.next.next.next.next.next = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">7</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0-&gt;9-&gt;8-&gt;6-&gt;7-&gt;null</span></span><br><span class="line"><span class="type">Node</span> <span class="variable">head2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">0</span>);</span><br><span class="line">head2.next = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">9</span>);</span><br><span class="line">head2.next.next = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">8</span>);</span><br><span class="line">head2.next.next.next = head1.next.next.next.next.next; <span class="comment">// 8-&gt;6</span></span><br><span class="line">System.out.println(getIntersectNode(head1, head2).value);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7-&gt;4...</span></span><br><span class="line">head1 = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">1</span>);</span><br><span class="line">head1.next = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">2</span>);</span><br><span class="line">head1.next.next = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">3</span>);</span><br><span class="line">head1.next.next.next = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">4</span>);</span><br><span class="line">head1.next.next.next.next = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">5</span>);</span><br><span class="line">head1.next.next.next.next.next = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">6</span>);</span><br><span class="line">head1.next.next.next.next.next.next = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">7</span>);</span><br><span class="line">head1.next.next.next.next.next.next = head1.next.next.next; <span class="comment">// 7-&gt;4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 0-&gt;9-&gt;8-&gt;2...</span></span><br><span class="line">head2 = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">0</span>);</span><br><span class="line">head2.next = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">9</span>);</span><br><span class="line">head2.next.next = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">8</span>);</span><br><span class="line">head2.next.next.next = head1.next; <span class="comment">// 8-&gt;2</span></span><br><span class="line">System.out.println(getIntersectNode(head1, head2).value);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0-&gt;9-&gt;8-&gt;6-&gt;4-&gt;5-&gt;6..</span></span><br><span class="line">head2 = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">0</span>);</span><br><span class="line">head2.next = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">9</span>);</span><br><span class="line">head2.next.next = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">8</span>);</span><br><span class="line">head2.next.next.next = head1.next.next.next.next.next; <span class="comment">// 8-&gt;6</span></span><br><span class="line">System.out.println(getIntersectNode(head1, head2).value);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4、二叉树"><a href="#4、二叉树" class="headerlink" title="4、二叉树"></a>4、二叉树</h2><h3 id="递归序"><a href="#递归序" class="headerlink" title="递归序"></a>递归序</h3><p>从顶点开始，先遍历完左子树回到中结点，再遍历右子树。类似中序遍历(类似)，看下图。</p><p>对于一个二叉树来说，只要是递归遍历，不管递归的顺序的是怎么样的，一个结点必然会被访问三次，之所以会有不同的遍历，就是在递归序的基础上做一些限制。</p><p>比如下面的例子，每个结点都被访问了三次，看4567，尽管没有子节点，但是对于递归来说，它会继续往下遍历，当检查到其下无孩子时return，这又是一次，然后是右孩子，没有return，又是一次。就是说虽然不做什么，但从递归序的角度来看，每个结点都会有三次访问。</p><p>前序：只保留递归序第一次访问。</p><p>中序：只保留递归序第二次访问。</p><p>后序：只保留递归序第三次访问。</p><p><img src="C:\Users\jyj123\AppData\Roaming\Typora\typora-user-images\image-20230227210954421.png" alt="image-20230227210954421"></p><p><img src="C:\Users\jyj123\AppData\Roaming\Typora\typora-user-images\image-20230227212012245.png" alt="image-20230227212012245"></p><h3 id="三种遍历的非递归实现"><a href="#三种遍历的非递归实现" class="headerlink" title="三种遍历的非递归实现"></a>三种遍历的非递归实现</h3><p>任何递归都可以用非递归的方式实现。原先只不过是系统替你压栈，现在我们自己实现。</p><h4 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h4><p>准备一个栈，先说流程：</p><p>先将头结点压入栈。</p><p>1、弹出一个结点，记为cur；</p><p>2、打印cur；</p><p>3、让cur的孩子进栈，先压右，再压左；</p><p>4、重复上面的过程。</p><p>当弹出结点打印完成后，发现没有左右孩子，那么就什么都不做，继续重复，弹出下一个。</p><h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><p>从先序遍历我们可以知道：先右再左进栈，出来的时候会变成先左再右，也就是 头右左 变成了头左右，这就是先序遍历的方式。</p><p>那么，我们现在如果一开始就先左进栈再右进栈，那么最后不就会变成 头右左吗，就是和上面反过来。</p><p>好，了解了上面那些，下面说一下流程：</p><p>先将头结点压入栈。</p><p>1、弹出一个结点，记为cur；</p><p>2、不打印，而是将cur暂存到另一个栈中；</p><p>3、让cur的孩子进第一个栈，先压左，再压右；</p><p>4、重复上面的过程。</p><p>5、最后，输出第二个栈的结点数据，就是依次出栈。</p><p>需要知道的是：在第三步的时候，因为我们先压左，再压右，所以实际上出来的是头右左，然后我们又将每一个弹出的结点放到了另一个栈中，现在，我们输出第二个栈中的数据，不就是将头右左反过来吗，从 头右左 变成了 左右头，因为栈是先进后出的结构，这样，最终的结果就是后序遍历。</p><h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><p>对中序遍历来说，数据进栈的顺序应当是：左右头，注意，是进栈的顺序。</p><p>从头结点开始，先将所有的左结点全部入栈，然后弹出，进行打印，然后看弹出结点是否有右子树结点，若有，则对这个右子树结点重复上面的操作。</p><p>下面说一下流程：</p><p>1、从头结点开始，先将所有的左子树入栈；</p><p>2、弹出结点cur，打印；</p><p>3、检查cur是否有右孩子；</p><p>4、若有右孩子，则重复上面的步骤；</p><p>经过上面的步骤，打印出来的就是中序遍历的数据。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p>下面是上面三种遍历的非递归代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> class10;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Code03_UnRecursiveTraversalBT</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> value;</span><br><span class="line"><span class="keyword">public</span> Node left;</span><br><span class="line"><span class="keyword">public</span> Node right;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> v)</span> &#123;</span><br><span class="line">value = v;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">pre</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">System.out.print(<span class="string">&quot;pre-order: &quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (head != <span class="literal">null</span>) &#123;</span><br><span class="line">Stack&lt;Node&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;Node&gt;();</span><br><span class="line">stack.add(head);</span><br><span class="line"><span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">head = stack.pop();</span><br><span class="line">System.out.print(head.value + <span class="string">&quot; &quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (head.right != <span class="literal">null</span>) &#123;</span><br><span class="line">stack.push(head.right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (head.left != <span class="literal">null</span>) &#123;</span><br><span class="line">stack.push(head.left);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">in</span><span class="params">(Node cur)</span> &#123;</span><br><span class="line">System.out.print(<span class="string">&quot;in-order: &quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">Stack&lt;Node&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;Node&gt;();</span><br><span class="line"><span class="keyword">while</span> (!stack.isEmpty() || cur != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">stack.push(cur);</span><br><span class="line">cur = cur.left;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">cur = stack.pop();</span><br><span class="line">System.out.print(cur.value + <span class="string">&quot; &quot;</span>);</span><br><span class="line">cur = cur.right;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">pos1</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">System.out.print(<span class="string">&quot;pos-order: &quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (head != <span class="literal">null</span>) &#123;</span><br><span class="line">Stack&lt;Node&gt; s1 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;Node&gt;();</span><br><span class="line">Stack&lt;Node&gt; s2 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;Node&gt;();</span><br><span class="line">s1.push(head);</span><br><span class="line"><span class="keyword">while</span> (!s1.isEmpty()) &#123;</span><br><span class="line">head = s1.pop(); <span class="comment">// 头 右 左</span></span><br><span class="line">s2.push(head);</span><br><span class="line"><span class="keyword">if</span> (head.left != <span class="literal">null</span>) &#123;</span><br><span class="line">s1.push(head.left);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (head.right != <span class="literal">null</span>) &#123;</span><br><span class="line">s1.push(head.right);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 左 右 头</span></span><br><span class="line"><span class="keyword">while</span> (!s2.isEmpty()) &#123;</span><br><span class="line">System.out.print(s2.pop().value + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">pos2</span><span class="params">(Node h)</span> &#123;</span><br><span class="line">System.out.print(<span class="string">&quot;pos-order: &quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (h != <span class="literal">null</span>) &#123;</span><br><span class="line">Stack&lt;Node&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;Node&gt;();</span><br><span class="line">stack.push(h);</span><br><span class="line"><span class="type">Node</span> <span class="variable">c</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">c = stack.peek();</span><br><span class="line"><span class="keyword">if</span> (c.left != <span class="literal">null</span> &amp;&amp; h != c.left &amp;&amp; h != c.right) &#123;</span><br><span class="line">stack.push(c.left);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (c.right != <span class="literal">null</span> &amp;&amp; h != c.right) &#123;</span><br><span class="line">stack.push(c.right);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">System.out.print(stack.pop().value + <span class="string">&quot; &quot;</span>);</span><br><span class="line">h = c;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">Node</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">1</span>);</span><br><span class="line">head.left = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">2</span>);</span><br><span class="line">head.right = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">3</span>);</span><br><span class="line">head.left.left = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">4</span>);</span><br><span class="line">head.left.right = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">5</span>);</span><br><span class="line">head.right.left = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">6</span>);</span><br><span class="line">head.right.right = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">pre(head);</span><br><span class="line">System.out.println(<span class="string">&quot;========&quot;</span>);</span><br><span class="line">in(head);</span><br><span class="line">System.out.println(<span class="string">&quot;========&quot;</span>);</span><br><span class="line">pos1(head);</span><br><span class="line">System.out.println(<span class="string">&quot;========&quot;</span>);</span><br><span class="line">pos2(head);</span><br><span class="line">System.out.println(<span class="string">&quot;========&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h4><p>层序遍历就是一层一层遍历，与上面三中遍历不同的是，它使用队列来实现。</p><p>下面说流程：</p><p>1、将头结点放入到对列；</p><p>2、弹出，打印；</p><p>3、让结点的孩子进队列，先左后右；</p><p>4、重复上面的过程。</p><p>层序遍历遍历完每一层后，又会到下一层开头去遍历。</p><h2 id="5、利用层序遍历计算出二叉树的宽度"><a href="#5、利用层序遍历计算出二叉树的宽度" class="headerlink" title="5、利用层序遍历计算出二叉树的宽度"></a>5、利用层序遍历计算出二叉树的宽度</h2><p>从上面我们可以知道，层序遍历会从上到下依次打印出二叉树，其实，这种遍历已经是一层一层遍历的了，问题的关键是，我们现在知道遍历最后的结果是什么，但是我们想返回的是最宽的一层，这也是二叉树的宽度。</p><p>那么，怎么解决？</p><p>关键就是我们要记录每一层的数据是多少个，这样，其实就是将最后遍历的数组给分了块了。</p><p>怎么记录？</p><p>结点进队列前，我们必须要知道结点当前属于哪一层，那么我们让当前层数对应的结点数++，这就是基本思路。</p><p>基于这个思路，这里有两种方法，一种是哈希表的，另外一种是不用哈希表的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> class11;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Code05_TreeMaxWidth</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> value;</span><br><span class="line"><span class="keyword">public</span> Node left;</span><br><span class="line"><span class="keyword">public</span> Node right;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.value = data;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxWidthUseMap</span><span class="params">(Node head)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">Queue&lt;Node&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">queue.add(head);</span><br><span class="line"><span class="comment">// key 在 哪一层，value</span></span><br><span class="line">HashMap&lt;Node, Integer&gt; levelMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">levelMap.put(head, <span class="number">1</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">curLevel</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">// 当前你正在统计哪一层的宽度</span></span><br><span class="line"><span class="type">int</span> <span class="variable">curLevelNodes</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 当前层curLevel层，宽度目前是多少</span></span><br><span class="line"><span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line"><span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> queue.poll();</span><br><span class="line"><span class="type">int</span> <span class="variable">curNodeLevel</span> <span class="operator">=</span> levelMap.get(cur);</span><br><span class="line"><span class="keyword">if</span> (cur.left != <span class="literal">null</span>) &#123;</span><br><span class="line">levelMap.put(cur.left, curNodeLevel + <span class="number">1</span>);</span><br><span class="line">queue.add(cur.left);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (cur.right != <span class="literal">null</span>) &#123;</span><br><span class="line">levelMap.put(cur.right, curNodeLevel + <span class="number">1</span>);</span><br><span class="line">queue.add(cur.right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (curNodeLevel == curLevel) &#123;</span><br><span class="line">curLevelNodes++;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">max = Math.max(max, curLevelNodes);</span><br><span class="line">curLevel++;</span><br><span class="line">curLevelNodes = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">max = Math.max(max, curLevelNodes);</span><br><span class="line"><span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxWidthNoMap</span><span class="params">(Node head)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">Queue&lt;Node&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">queue.add(head);</span><br><span class="line"><span class="type">Node</span> <span class="variable">curEnd</span> <span class="operator">=</span> head; <span class="comment">// 当前层，最右节点是谁</span></span><br><span class="line"><span class="type">Node</span> <span class="variable">nextEnd</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 下一层，最右节点是谁</span></span><br><span class="line"><span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">curLevelNodes</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 当前层的节点数</span></span><br><span class="line"><span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line"><span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> queue.poll();</span><br><span class="line"><span class="keyword">if</span> (cur.left != <span class="literal">null</span>) &#123;</span><br><span class="line">queue.add(cur.left);</span><br><span class="line">nextEnd = cur.left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (cur.right != <span class="literal">null</span>) &#123;</span><br><span class="line">queue.add(cur.right);</span><br><span class="line">nextEnd = cur.right;</span><br><span class="line">&#125;</span><br><span class="line">curLevelNodes++;</span><br><span class="line"><span class="keyword">if</span> (cur == curEnd) &#123;</span><br><span class="line">max = Math.max(max, curLevelNodes);</span><br><span class="line">curLevelNodes = <span class="number">0</span>;</span><br><span class="line">curEnd = nextEnd;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title function_">generateRandomBST</span><span class="params">(<span class="type">int</span> maxLevel, <span class="type">int</span> maxValue)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> generate(<span class="number">1</span>, maxLevel, maxValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title function_">generate</span><span class="params">(<span class="type">int</span> level, <span class="type">int</span> maxLevel, <span class="type">int</span> maxValue)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (level &gt; maxLevel || Math.random() &lt; <span class="number">0.5</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">Node</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>((<span class="type">int</span>) (Math.random() * maxValue));</span><br><span class="line">head.left = generate(level + <span class="number">1</span>, maxLevel, maxValue);</span><br><span class="line">head.right = generate(level + <span class="number">1</span>, maxLevel, maxValue);</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">maxLevel</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">maxValue</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">testTimes</span> <span class="operator">=</span> <span class="number">1000000</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; testTimes; i++) &#123;</span><br><span class="line"><span class="type">Node</span> <span class="variable">head</span> <span class="operator">=</span> generateRandomBST(maxLevel, maxValue);</span><br><span class="line"><span class="keyword">if</span> (maxWidthUseMap(head) != maxWidthNoMap(head)) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Oops!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;finish!&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="6、打印一个二叉树的结构"><a href="#6、打印一个二叉树的结构" class="headerlink" title="6、打印一个二叉树的结构"></a>6、打印一个二叉树的结构</h2><p>就是将给定的一个二叉树在控制台打印出来。每个人写法不一样，下面只是其中的一个例子。</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> class11;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Code04_PrintBinaryTree</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> value;</span><br><span class="line"><span class="keyword">public</span> Node left;</span><br><span class="line"><span class="keyword">public</span> Node right;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.value = data;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printTree</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Binary Tree:&quot;</span>);</span><br><span class="line">printInOrder(head, <span class="number">0</span>, <span class="string">&quot;H&quot;</span>, <span class="number">17</span>);</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printInOrder</span><span class="params">(Node head, <span class="type">int</span> height, String to, <span class="type">int</span> len)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">printInOrder(head.right, height + <span class="number">1</span>, <span class="string">&quot;v&quot;</span>, len);</span><br><span class="line"><span class="type">String</span> <span class="variable">val</span> <span class="operator">=</span> to + head.value + to;</span><br><span class="line"><span class="type">int</span> <span class="variable">lenM</span> <span class="operator">=</span> val.length();</span><br><span class="line"><span class="type">int</span> <span class="variable">lenL</span> <span class="operator">=</span> (len - lenM) / <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">lenR</span> <span class="operator">=</span> len - lenM - lenL;</span><br><span class="line">val = getSpace(lenL) + val + getSpace(lenR);</span><br><span class="line">System.out.println(getSpace(height * len) + val);</span><br><span class="line">printInOrder(head.left, height + <span class="number">1</span>, <span class="string">&quot;^&quot;</span>, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getSpace</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">space</span> <span class="operator">=</span> <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">buf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">buf.append(space);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> buf.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">Node</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">1</span>);</span><br><span class="line">head.left = <span class="keyword">new</span> <span class="title class_">Node</span>(-<span class="number">222222222</span>);</span><br><span class="line">head.right = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">3</span>);</span><br><span class="line">head.left.left = <span class="keyword">new</span> <span class="title class_">Node</span>(Integer.MIN_VALUE);</span><br><span class="line">head.right.left = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">55555555</span>);</span><br><span class="line">head.right.right = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">66</span>);</span><br><span class="line">head.left.left.right = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">777</span>);</span><br><span class="line">printTree(head);</span><br><span class="line"></span><br><span class="line">head = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">1</span>);</span><br><span class="line">head.left = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">2</span>);</span><br><span class="line">head.right = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">3</span>);</span><br><span class="line">head.left.left = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">4</span>);</span><br><span class="line">head.right.left = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">5</span>);</span><br><span class="line">head.right.right = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">6</span>);</span><br><span class="line">head.left.left.right = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">7</span>);</span><br><span class="line">printTree(head);</span><br><span class="line"></span><br><span class="line">head = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">1</span>);</span><br><span class="line">head.left = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">1</span>);</span><br><span class="line">head.right = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">1</span>);</span><br><span class="line">head.left.left = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">1</span>);</span><br><span class="line">head.right.left = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">1</span>);</span><br><span class="line">head.right.right = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">1</span>);</span><br><span class="line">head.left.left.right = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">1</span>);</span><br><span class="line">printTree(head);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有需要的时候可以调用这个函数。</p><h2 id="7、算法稳定性"><a href="#7、算法稳定性" class="headerlink" title="7、算法稳定性"></a>7、算法稳定性</h2><p>一般衡量算法的三个指标：时间复杂度、空间复杂度、稳定性。</p><p>稳定性是指：排完序之后，相同数据的相对位置和之前相比没有发生变化。</p><p>比如【234562562】</p><p>排完序后【22234566】，三个2、两个6的相对位置保持不变，这就是稳定性。</p><p>那稳定性在现实中有什么意义吗？</p><p>当然有。比如对一件商品，先对价格排序，在这个基础上进行美观度排序，最后展现出来，那我最后得到的就是物美价廉的东西排序。</p><p>正是因为稳定性，保持了相对位置不变，才能得到这样的结果，这对一些有这方面要求的公司很重要。</p><h2 id="8、一些算法的说法和坑"><a href="#8、一些算法的说法和坑" class="headerlink" title="8、一些算法的说法和坑"></a>8、一些算法的说法和坑</h2><p><img src="C:\Users\jyj123\AppData\Roaming\Typora\typora-user-images\image-20230216002244327.png" alt="image-20230216002244327"></p><h2 id="9、算法在工程上的考虑"><a href="#9、算法在工程上的考虑" class="headerlink" title="9、算法在工程上的考虑"></a>9、算法在工程上的考虑</h2><p><img src="C:\Users\jyj123\AppData\Roaming\Typora\typora-user-images\image-20230216002609672.png" alt="image-20230216002609672"></p><p>具体的改进就是结合各种排序的优劣，具体情况具体分析。通常都将各种排序结合起来使用。</p><p>比如问题规模一开始很大，用了快排，在递归一层一层往下的时候，当数据规模&lt;60时，用插入排序，因为插入排序在常数级别的表现很好。</p><p>还有一点就是稳定性的考虑。比如说面试官问你：Arrays.sort()为什么对基础类型采用快速排序，对传入的引用类型，或者说自定义类型采用归并排序？这就是稳定性的考虑。因为基础类型默认就是不考虑稳定性的，而自定义类型不确定，那我就考虑稳定性。</p><h2 id="10、二分法的详解与扩展"><a href="#10、二分法的详解与扩展" class="headerlink" title="10、二分法的详解与扩展"></a>10、二分法的详解与扩展</h2><p>1、在一个有序数组中，找某个数是否存在；</p><p>用二分法不断二分，一定可以求到。每次将数组范围缩小一半，时间复杂度为O(logN)。<strong>不写底数默认就是2，即O(log2N).</strong></p><p>2、在一个有序数组中，找&gt;&#x3D;某个数最左侧数的位置；</p><p>1的情况是可以直接找出值就可以了，2不行。比如【2 2 3 3 4 4 4  5 5 5】数组，找&gt;&#x3D;3的数，取中间值，第二个4，这还不行，因为要找到最左侧数，然后将这个4左边继续二分，这样依次二分直到找到值。</p><p>3、局部最小值问题；</p><h2 id="11、求中点"><a href="#11、求中点" class="headerlink" title="11、求中点"></a>11、求中点</h2><p>1、mid&#x3D;（L+R）&#x2F;2</p><p>问题：L+R可能会溢出，这样mid求出来的值就可能为负数。</p><p>2、mid&#x3D;L+（R-L）&#x2F;2</p><p>这样就不会溢出。</p><p>3、mid&#x3D;L+(（R-L）&gt;&gt;1)</p><p>右移一位就相当于除以2。这种方法比第二种更快。</p><h2 id="12、master公式"><a href="#12、master公式" class="headerlink" title="12、master公式"></a>12、master公式</h2><p><img src="C:\Users\jyj123\AppData\Roaming\Typora\typora-user-images\image-20230211201031183.png" alt="image-20230211201031183"></p><p>log(b,a)的意思是log以b为底的a。</p><p>例子，求最大值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> class03;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Code08_GetMax</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求arr中的最大值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getMax</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> process(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// arr[L..R]范围上求最大值  L ... R   N</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">process</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> L, <span class="type">int</span> R)</span> &#123;</span><br><span class="line"><span class="comment">// arr[L..R]范围上只有一个数，直接返回，base case</span></span><br><span class="line"><span class="keyword">if</span> (L == R) &#123; </span><br><span class="line"><span class="keyword">return</span> arr[L];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// L...R 不只一个数</span></span><br><span class="line"><span class="comment">// mid = (L + R) / 2</span></span><br><span class="line"><span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> L + ((R - L) &gt;&gt; <span class="number">1</span>); <span class="comment">// 中点   1</span></span><br><span class="line"><span class="type">int</span> <span class="variable">leftMax</span> <span class="operator">=</span> process(arr, L, mid);</span><br><span class="line"><span class="type">int</span> <span class="variable">rightMax</span> <span class="operator">=</span> process(arr, mid + <span class="number">1</span>, R);</span><br><span class="line">        <span class="comment">//两个调完之后的值比大小，时间复杂度为1</span></span><br><span class="line"><span class="keyword">return</span> Math.max(leftMax, rightMax);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是将数组分成左右两部分依次递归。所以b&#x3D;2，有两次，所以a&#x3D;2，其它部分为O(1),所以d&#x3D;1。</p><p>所以带入公式，有 1&gt;0,所以时间复杂度为O(N)。</p>]]></content>
      
      
      <categories>
          
          <category> 算法和数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>文章分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>关于</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/custom.css"/>
      <url>/css/custom.css</url>
      
        <content type="html"><![CDATA[/* 页脚与头图透明 */#footer {    background: transparent !important;  }  #page-header {    background: transparent !important;  }    /* 白天模式遮罩透明 */  #footer::before {    background: transparent !important;  }  #page-header::before {    background: transparent !important;  }    /* 夜间模式遮罩透明 */  [data-theme="dark"] #footer::before {    background: transparent !important;  }  [data-theme="dark"] #page-header::before {    background: transparent !important;  }  /* 翻页按钮居中 */#pagination {    width: 100%;    margin: auto;  }/*个人卡片渐变色*//* 侧边栏个人信息卡片动态渐变色 */#aside-content > .card-widget.card-info {    background: linear-gradient(      -45deg,      #e8d8b9,      #eccec5,      #a3e9eb,      #bdbdf0,      #eec1ea    );    box-shadow: 0 0 5px rgb(66, 68, 68);    position: relative;    background-size: 400% 400%;    -webkit-animation: Gradient 10s ease infinite;    -moz-animation: Gradient 10s ease infinite;    animation: Gradient 10s ease infinite !important;  }  @-webkit-keyframes Gradient {    0% {      background-position: 0% 50%;    }    50% {      background-position: 100% 50%;    }    100% {      background-position: 0% 50%;    }  }  @-moz-keyframes Gradient {    0% {      background-position: 0% 50%;    }    50% {      background-position: 100% 50%;    }    100% {      background-position: 0% 50%;    }  }  @keyframes Gradient {    0% {      background-position: 0% 50%;    }    50% {      background-position: 100% 50%;    }    100% {      background-position: 0% 50%;    }  }    /* 黑夜模式适配 */  [data-theme="dark"] #aside-content > .card-widget.card-info {    background: #191919ee;  }    /* 个人信息Follow me按钮 */  #aside-content > .card-widget.card-info > #card-info-btn {    background-color: #3eb8be;    border-radius: 8px;  }  /* 小冰分类分类磁铁黑夜模式适配 *//* 一般状态 */[data-theme="dark"] .magnet_link_context {    background: #1e1e1e;    color: antiquewhite;  }/* 鼠标悬浮状态 */[data-theme="dark"] .magnet_link_context:hover {background: #3ecdf1;color: #f2f2f2;}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>友链</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>电影</title>
      <link href="/movies/index.html"/>
      <url>/movies/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>音乐</title>
      <link href="/music/index.html"/>
      <url>/music/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
